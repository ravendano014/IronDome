<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Iron Dome Enhanced - Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            background-color: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: none;
            font-family: 'Arial', sans-serif;
        }

        .game-container {
            position: relative;
            background-color: #000;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            width: 95vw;
            height: calc(95vw * 0.75); /* Mantener relación de aspecto 4:3 */
            max-width: calc(100vh * 1.333); /* Máximo basado en altura */
            max-height: 90vh;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid lime;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        h1 {
            color: #0ff;
            text-align: center;
            font-size: 28px;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 8px;
            padding: 0 10px;
        }

        /* Estilos para la pantalla de inicio */
        #splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1001;
            padding: 20px;
            cursor: pointer;
        }

        #splash-screen h2 {
            color: #0ff;
            font-size: 3em;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #0ff;
        }

        #splash-screen p {
            font-size: 1.2em;
            margin: 5px 0;
            color: #eee;
            max-width: 90%;
        }

        #splash-screen .click-to-start {
            margin-top: 30px;
            font-size: 1.8em;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            animation: pulse 1.5s infinite alternate;
        }

        /* Estilo para la pantalla de pausa */
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: #0ff;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            padding: 20px;
            text-align: center;
        }

        #pause-screen h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0ff;
        }

        #pause-screen p {
            font-size: 1.3em;
            margin: 8px 0;
        }

        /* Tooltip para las habilidades */
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1003;
            display: none;
            text-align: center;
            max-width: 200px;
            border: 1px solid #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* Indicador de baterías */
        .battery-indicators {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 10px;
            padding: 0 10px;
        }
        
        .battery-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }
        
        .battery-icon {
            width: 30px;
            height: 30px;
            margin-bottom: 5px;
            background-color: #333;
            border: 1px solid #0ff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .battery-1 .battery-icon { background: linear-gradient(to bottom, #ffff00, #888800); }
        .battery-2 .battery-icon { background: linear-gradient(to bottom, #ff9900, #885500); }
        .battery-3 .battery-icon { background: linear-gradient(to bottom, #00ff00, #008800); }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
        
        /* Botones para móviles */
        .mobile-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 100, 255, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 2px solid #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            user-select: none;
            touch-action: manipulation;
        }
        
        .mobile-btn:active {
            background: rgba(0, 200, 255, 0.9);
            transform: scale(0.95);
        }
        
        .pause-btn {
            background: rgba(200, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div>
        <h1>Iron Dome Enhanced</h1>
        <div class="game-container">
            <canvas></canvas>
            <div class="crosshair"></div>
            <div class="tooltip" id="battery-tooltip"></div>
            
            <div class="battery-indicators">
                <div class="battery-indicator battery-1">
                    <div class="battery-icon">I</div>
                    <div>Immunity</div>
                </div>
                <div class="battery-indicator battery-2">
                    <div class="battery-icon">B</div>
                    <div>Boost</div>
                </div>
                <div class="battery-indicator battery-3">
                    <div class="battery-icon">L</div>
                    <div>Laser</div>
                </div>
            </div>
            
            <div class="mobile-controls">
                <div class="mobile-btn pause-btn" id="pause-btn">⏸</div>
                <div class="mobile-btn" id="immunity-btn">I</div>
                <div class="mobile-btn" id="boost-btn">B</div>
                <div class="mobile-btn" id="laser-btn">L</div>
            </div>
            
            <div id="splash-screen">
                <h2>Iron Dome Enhanced</h2>
                <p>Defend your cities from the enemy missile rain!</p>
                <p>Tap to aim and tap to launch a defensive missile.</p>
                <p>Double-tap on batteries to activate special abilities:</p>
                <p>- Immunity: Protect cities for 3 waves</p>
                <p>- Boost: Double explosion radius for 5 waves</p>
                <p>- Laser: Activate Iron Beam for 7 waves</p>
                <p class="click-to-start">Tap anywhere to start</p>
            </div>

            <div id="pause-screen">
                <h2>GAME PAUSED</h2>
                <p>Tap Resume to continue</p>
                <p>Controls:</p>
                <p>Double-tap batteries for special abilities:</p>
                <p>Immunity (I) - City protection (3 waves)</p>
                <p>Boost (B) - Double explosion radius (5 waves)</p>
                <p>Laser (L) - Iron Beam activation (7 waves)</p>
                <div class="mobile-btn" id="resume-btn" style="margin-top: 20px;">Resume</div>
            </div>
        </div>
    </div>

    <script>
        // Iron Dome Enhanced - Mobile Version
        const missileCommand = (function() {
            const canvas = document.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            const gameContainer = document.querySelector('.game-container');
            const crosshair = document.querySelector('.crosshair');
            const splashScreen = document.getElementById('splash-screen');
            const pauseScreen = document.getElementById('pause-screen');
            const tooltip = document.getElementById('battery-tooltip');
            const pauseBtn = document.getElementById('pause-btn');
            const resumeBtn = document.getElementById('resume-btn');
            const immunityBtn = document.getElementById('immunity-btn');
            const boostBtn = document.getElementById('boost-btn');
            const laserBtn = document.getElementById('laser-btn');

            // Variables para dimensiones dinámicas
            let CANVAS_WIDTH = 800;
            let CANVAS_HEIGHT = 600;
            let scaleFactor = 1;
            
            // Actualizar dimensiones del canvas
            function updateCanvasDimensions() {
                const container = canvas.parentElement;
                CANVAS_WIDTH = container.clientWidth;
                CANVAS_HEIGHT = container.clientHeight;
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                
                // Calcular factor de escala basado en el tamaño original (800x600)
                scaleFactor = Math.min(CANVAS_WIDTH / 800, CANVAS_HEIGHT / 600);
                
                // Redibujar el juego si ya ha comenzado
                if (gameStarted) {
                    drawGameState();
                }
            }

            // Escalar un valor según el tamaño actual del canvas
            function scaleValue(value) {
                return value * scaleFactor;
            }

            // Escalar una posición horizontal
            function scaleX(x) {
                return x * (CANVAS_WIDTH / 800);
            }

            // Escalar una posición vertical
            function scaleY(y) {
                return y * (CANVAS_HEIGHT / 600);
            }

            // Constants
            const GROUND_HEIGHT = scaleValue(100);
            const MAX_STEALTH_PLANES_PER_LEVEL = 10;
            const MAX_CARGO_PLANES_PER_LEVEL = 10;
            const WAVES_PER_LEVEL = 10;

            const MISSILE = {
                active: 1,
                exploding: 2,
                imploding: 3,
                exploded: 4
            };

            // Variables del juego
            let score = 0;
            let level = 1;
            let cities = [];
            let antiMissileBatteries = [];
            let playerMissiles = [];
            let enemyMissiles = [];
            let timerID;
            let gameStarted = false;
            let gamePaused = false;
            let currentWave = 0;
            let waveActive = false;
            let targetCrosshairX = 0;
            let targetCrosshairY = 0;
            let currentCrosshairX = 0;
            let currentCrosshairY = 0;
            const smoothingFactor = 0.15;
            let bonusMissilesForNextWave = 0;
            let planesShotDownThisLevel = 0;
            let reconstructedCount = 0;
            let extraMissilesFromSpyPlane = 0;
            let enemyPlane = null;
            let planesPerLevel = 0;
            const MAX_PLANES_PER_LEVEL = 10;
            let spyPlane = null;
            let spyPlanesAppearedThisLevel = 0;
            const MAX_SPY_PLANES_PER_LEVEL = 10;
            let spyPlaneWaveMissileBonus = 0;
            let stealthPlane = null;
            let stealthPlanesAppearedThisLevel = 0;
            let stealthPlaneExplosionBonus = 1;
            let stealthPlaneSpawnedThisLevel = false;
            let cargoPlane = null;
            let cargoPlanesAppearedThisLevel = 0;
            let cargoPlaneEnemyMissileReduction = 0;
            let cargoPlaneSpawnedThisLevel = false;
            let killerPlane = null;
            let killerPlanesAppearedThisLevel = 0;
            const MAX_KILLER_PLANES_PER_LEVEL = 10;
            let citiesImmune = false;
            let killerPlaneSpawnedThisLevel = false;
            let immunityActive = false;
            let immunityWavesLeft = 0;
            let explosionBoostActive = false;
            let explosionBoostWavesLeft = 0;
            let enemyReductionActive = false;
            let enemyReductionWavesLeft = 0;
            let powerUpUsedThisLevel = {
                immunity: false,
                explosion: false,
                reduction: false
            };
            
            // Variables para el Easter Egg (Iron Beam Laser)
            let ironBeamActive = false;
            let ironBeamWavesLeft = 0;
            let ironBeamLasers = [];
            let lastBeamActivationTime = 0;
            const BEAM_COOLDOWN = 1000; // 1 segundo entre activaciones
            
            // Variables para el doble toque
            let lastTapTime = 0;
            let tapCount = 0;
            let lastTappedBattery = -1;

            // Initialize game
            function initialize() {
                updateCanvasDimensions();
                
                // Configurar evento de redimensionamiento
                window.addEventListener('resize', () => {
                    updateCanvasDimensions();
                });

                // Reset game state
                resetGameState();
                
                // Create cities
                createCities();
                
                // Create anti-missile batteries
                createBatteries();
                
                drawGameState();
            }

            function resetGameState() {
                cities = [];
                antiMissileBatteries = [];
                playerMissiles = [];
                enemyMissiles = [];
                score = 0;
                level = 1;
                currentWave = 0;
                waveActive = false;
                gameStarted = false;
                gamePaused = false;
                bonusMissilesForNextWave = 0;
                enemyPlane = null;
                planesPerLevel = 0;
                planesShotDownThisLevel = 0;
                reconstructedCount = 0;
                spyPlane = null;
                spyPlanesAppearedThisLevel = 0;
                spyPlaneWaveMissileBonus = 0;
                extraMissilesFromSpyPlane = 0;
                stealthPlane = null;
                stealthPlanesAppearedThisLevel = 0;
                stealthPlaneExplosionBonus = 1;
                stealthPlaneSpawnedThisLevel = false;
                cargoPlane = null;
                cargoPlanesAppearedThisLevel = 0;
                cargoPlaneEnemyMissileReduction = 0;
                cargoPlaneSpawnedThisLevel = false;
                killerPlane = null;
                killerPlanesAppearedThisLevel = 0;
                citiesImmune = false;
                killerPlaneSpawnedThisLevel = false;
                immunityActive = false;
                immunityWavesLeft = 0;
                explosionBoostActive = false;
                explosionBoostWavesLeft = 0;
                enemyReductionActive = false;
                enemyReductionWavesLeft = 0;
                powerUpUsedThisLevel = {
                    immunity: false,
                    explosion: false,
                    reduction: false
                };
                ironBeamActive = false;
                ironBeamWavesLeft = 0;
                ironBeamLasers = [];
                lastBeamActivationTime = 0;
            }

            function createCities() {
                cities.push(new City(scaleX(100), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
                cities.push(new City(scaleX(200), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
                cities.push(new City(scaleX(300), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
                cities.push(new City(scaleX(500), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
                cities.push(new City(scaleX(600), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
                cities.push(new City(scaleX(700), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT + 20)));
            }

            function createBatteries() {
                // Left battery - Immunity
                antiMissileBatteries.push(new AntiMissileBattery(scaleX(50), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT), 'immunity'));
                // Middle battery - Explosion boost
                antiMissileBatteries.push(new AntiMissileBattery(scaleX(400), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT), 'explosion'));
                // Right battery - Iron Beam
                antiMissileBatteries.push(new AntiMissileBattery(scaleX(750), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT), 'laser'));
            }

            // Setup event listeners
            function setupListeners() {
                splashScreen.addEventListener('click', startGame);
                splashScreen.addEventListener('touchend', startGame);
                
                gameContainer.addEventListener('click', handleTap);
                gameContainer.addEventListener('touchend', handleTap);
                
                gameContainer.addEventListener('mousemove', handleMouseMove);
                gameContainer.addEventListener('touchmove', handleTouchMove);
                
                pauseBtn.addEventListener('click', togglePause);
                pauseBtn.addEventListener('touchend', togglePause);
                
                resumeBtn.addEventListener('click', togglePause);
                resumeBtn.addEventListener('touchend', togglePause);
                
                immunityBtn.addEventListener('click', () => activateImmunity());
                immunityBtn.addEventListener('touchend', () => activateImmunity());
                
                boostBtn.addEventListener('click', () => activateExplosionBoost());
                boostBtn.addEventListener('touchend', () => activateExplosionBoost());
                
                laserBtn.addEventListener('click', () => activateIronBeam());
                laserBtn.addEventListener('touchend', () => activateIronBeam());
            }
            
            function startGame() {
                if (!gameStarted) {
                    splashScreen.style.display = 'none';
                    gameStarted = true;
                    initializeLevel();
                    crosshair.style.display = 'block';
                }
            }

            // Handle tap events (single and double)
            function handleTap(event) {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                
                if (event.type === 'touchend') {
                    if (event.changedTouches.length === 0) return;
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                // Check if tap is on a battery
                const batteryIndex = getBatteryAtPosition(canvasX, canvasY);
                
                if (batteryIndex !== -1) {
                    const currentTime = new Date().getTime();
                    const tapDelay = currentTime - lastTapTime;
                    
                    if (tapDelay < 300 && batteryIndex === lastTappedBattery) {
                        // Double tap on battery - activate ability
                        tapCount = 0;
                        activateBatteryAbility(batteryIndex);
                    } else {
                        // Single tap on battery
                        tapCount = 1;
                        lastTappedBattery = batteryIndex;
                        
                        setTimeout(() => {
                            if (tapCount === 1) {
                                playerShoot(clientX, clientY);
                                tapCount = 0;
                            }
                        }, 300);
                    }
                    
                    lastTapTime = currentTime;
                } else {
                    // Handle normal tap for shooting
                    playerShoot(clientX, clientY);
                }
            }
            
            // Get battery at position
            function getBatteryAtPosition(x, y) {
                for (let i = 0; i < antiMissileBatteries.length; i++) {
                    const battery = antiMissileBatteries[i];
                    const batteryLeft = battery.x - battery.width / 2;
                    const batteryRight = battery.x + battery.width / 2;
                    const batteryTop = battery.y - battery.height;
                    const batteryBottom = battery.y;
                    
                    if (x >= batteryLeft && x <= batteryRight && 
                        y >= batteryTop && y <= batteryBottom) {
                        return i;
                    }
                }
                return -1;
            }
            
            // Activate battery special ability
            function activateBatteryAbility(batteryIndex) {
                const battery = antiMissileBatteries[batteryIndex];
                
                if (!battery.active) {
                    showTooltip("Battery destroyed!", battery.x, battery.y - battery.height);
                    return;
                }
                
                switch (battery.specialAbility) {
                    case 'immunity':
                        activateImmunity();
                        showTooltip("Immunity activated! (3 waves)", battery.x, battery.y - battery.height);
                        break;
                    case 'explosion':
                        activateExplosionBoost();
                        showTooltip("Explosion boost activated! (5 waves)", battery.x, battery.y - battery.height);
                        break;
                    case 'laser':
                        activateIronBeam();
                        showTooltip("Iron Beam activated! (7 waves)", battery.x, battery.y - battery.height);
                        break;
                }
            }
            
            // Show tooltip
            function showTooltip(text, x, y) {
                tooltip.textContent = text;
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y - 40}px`;
                tooltip.style.display = 'block';
                
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 2000);
            }

            // Initialize level
            function initializeLevel() {
                playerMissiles = [];
                enemyMissiles = [];
                currentWave = 0; 
                enemyPlane = null;
                planesPerLevel = 0;
                planesShotDownThisLevel = 0;
                reconstructedCount = 0;
                spyPlane = null;
                spyPlanesAppearedThisLevel = 0;
                spyPlaneWaveMissileBonus = 0;
                extraMissilesFromSpyPlane = 0;
                stealthPlane = null;
                stealthPlanesAppearedThisLevel = 0;
                stealthPlaneExplosionBonus = 1;
                stealthPlaneSpawnedThisLevel = false;
                cargoPlane = null;
                cargoPlanesAppearedThisLevel = 0;
                cargoPlaneEnemyMissileReduction = 0;
                cargoPlaneSpawnedThisLevel = false;
                killerPlane = null;
                killerPlanesAppearedThisLevel = 0;
                citiesImmune = false;
                killerPlaneSpawnedThisLevel = false;
                immunityActive = false;
                immunityWavesLeft = 0;
                explosionBoostActive = false;
                explosionBoostWavesLeft = 0;
                enemyReductionActive = false;
                enemyReductionWavesLeft = 0;
                powerUpUsedThisLevel = {
                    immunity: false,
                    explosion: false,
                    reduction: false
                };
                
                // Reiniciar Iron Beam si estaba activo
                if (ironBeamActive) {
                    ironBeamLasers = [
                        new IronBeamLaser(scaleX(350), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT)),
                        new IronBeamLaser(scaleX(450), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT))
                    ];
                }

                startNextWave(); 
            }

            // Start next wave
            function startNextWave() {
                currentWave++;
                if (currentWave > WAVES_PER_LEVEL) {
                    checkEndLevel(); 
                    return;
                }

                // Update power-up counters
                if (immunityActive) {
                    immunityWavesLeft--;
                    if (immunityWavesLeft <= 0) {
                        immunityActive = false;
                        citiesImmune = false;
                    }
                }
                
                if (explosionBoostActive) {
                    explosionBoostWavesLeft--;
                    if (explosionBoostWavesLeft <= 0) {
                        explosionBoostActive = false;
                        stealthPlaneExplosionBonus = 1;
                    }
                }
                
                if (enemyReductionActive) {
                    enemyReductionWavesLeft--;
                    if (enemyReductionWavesLeft <= 0) {
                        enemyReductionActive = false;
                    }
                }
                
                // Update Iron Beam counter
                if (ironBeamActive) {
                    ironBeamWavesLeft--;
                    if (ironBeamWavesLeft <= 0) {
                        ironBeamActive = false;
                        ironBeamLasers = [];
                    }
                }

                const initialMissiles = 10;
                
                let missilesForThisWave = initialMissiles;
                if (level === 2 && currentWave === 1 && bonusMissilesForNextWave > 0) {
                    missilesForThisWave += bonusMissilesForNextWave;
                    bonusMissilesForNextWave = 0; 
                }

                const reductionPerTwoWaves = Math.floor((currentWave - 1) / 2);
                antiMissileBatteries.forEach(amb => {
                    if (amb.active) { 
                        amb.missilesLeft = Math.max(0, missilesForThisWave - reductionPerTwoWaves + spyPlaneWaveMissileBonus);
                    } else {
                        amb.missilesLeft = 0;
                    }
                });

                waveActive = true;
                createEnemyMissiles();
                spawnEnemyPlane(); 
                spawnSpyPlane();
                spawnStealthPlane();
                spawnCargoPlane();
                spawnKillerPlane();

                drawGameState(); 
                startLevel(); 
            }

            // Create enemy missiles with increasing difficulty
            function createEnemyMissiles() {
                const targets = viableTargets();
                let numMissiles;
                let baseSpeedFactor;

                numMissiles = 5 + (level * 2) + Math.floor(currentWave * 0.5); 
                baseSpeedFactor = 1 - (level * 0.05) - (currentWave * 0.01); 
                baseSpeedFactor = Math.max(0.2, baseSpeedFactor); 

                if (level === 1) {
                     switch (currentWave) {
                        case 1: numMissiles = 5; baseSpeedFactor = 0.8; break;
                        case 2: numMissiles = 7; baseSpeedFactor = 0.75; break;
                        case 3: numMissiles = 9; baseSpeedFactor = 0.7; break;
                        case 4: numMissiles = 11; baseSpeedFactor = 0.65; break;
                        case 5: numMissiles = 13; baseSpeedFactor = 0.6; break;
                        case 6: numMissiles = 15; baseSpeedFactor = 0.55; break;
                        case 7: numMissiles = 17; baseSpeedFactor = 0.5; break;
                        case 8: numMissiles = 19; baseSpeedFactor = 0.45; break;
                        case 9: numMissiles = 21; baseSpeedFactor = 0.4; break;
                        case 10: numMissiles = 25; baseSpeedFactor = 0.35; break;
                    }
                }

                // Apply Cargo Plane missile reduction
                numMissiles = Math.max(1, numMissiles - cargoPlaneEnemyMissileReduction);
                
                // Apply enemy reduction power-up
                if (enemyReductionActive) {
                    numMissiles = Math.max(1, numMissiles - 4);
                }

                for(let i = 0; i < numMissiles; i++) {
                    const isFast = Math.random() < 0.3; 
                    enemyMissiles.push(new EnemyMissile(targets, isFast, baseSpeedFactor));
                }
            }

            // Random number helper
            function rand(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // Draw game state
            function drawGameState() {
                drawBackground();
                drawCities();
                drawAntiMissileBatteries();
                drawScore();
                drawLevel();
                drawPowerUpStatus();
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(20)}px Arial`;
                ctx.fillText(`Wave: ${currentWave}/${WAVES_PER_LEVEL}`, CANVAS_WIDTH - scaleX(250), scaleY(30));
                updateCrosshairPosition();
            }

            // Draw power-up status
            function drawPowerUpStatus() {
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(14)}px Arial`;
                
                if (immunityActive) {
                    ctx.fillText(`Immunity: ${immunityWavesLeft} waves`, scaleX(20), scaleY(60));
                }
                
                if (explosionBoostActive) {
                    ctx.fillText(`Explosion Boost: ${explosionBoostWavesLeft} waves`, scaleX(20), scaleY(90));
                }
                
                if (enemyReductionActive) {
                    ctx.fillText(`Enemy Reduction: ${enemyReductionWavesLeft} waves`, scaleX(20), scaleY(120));
                }
                
                if (ironBeamActive) {
                    ctx.fillText(`Iron Beam: ${ironBeamWavesLeft} waves`, scaleX(20), scaleY(150));
                }
            }

            // Update crosshair position smoothly
            function updateCrosshairPosition() {
                currentCrosshairX += (targetCrosshairX - currentCrosshairX) * smoothingFactor;
                currentCrosshairY += (targetCrosshairY - currentCrosshairY) * smoothingFactor;

                crosshair.style.left = `${currentCrosshairX}px`;
                crosshair.style.top = `${currentCrosshairY}px`;
            }

            // Draw begin level screen
            function drawBeginLevel() {
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(scaleX(100), scaleY(150), scaleX(600), scaleY(300));
                
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(25)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('DEFEND YOUR CITIES', CANVAS_WIDTH / 2, scaleY(200));
                
                ctx.font = `bold ${scaleValue(20)}px Arial`;
                ctx.fillText(`LEVEL ${level}`, CANVAS_WIDTH / 2, scaleY(250));
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('TAP TO START', CANVAS_WIDTH / 2, scaleY(350));
                
                ctx.textAlign = 'left';
            }

            // Draw score
            function drawScore() {
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(20)}px Arial`;
                ctx.fillText(`Score: ${score}`, scaleX(50), scaleY(30));
            }

            // Draw level
            function drawLevel() {
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(20)}px Arial`;
                ctx.fillText(`Level: ${level}`, CANVAS_WIDTH - scaleX(120), scaleY(30));
            }

            // Draw end level screen
            function drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthPlaneBonusActive, cargoPlaneMissileReduction, killerPlaneImmunityActive) {
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(scaleX(50), scaleY(80), CANVAS_WIDTH - scaleX(100), scaleY(350));
                
                ctx.fillStyle = '#0ff';
                ctx.font = `bold ${scaleValue(25)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL COMPLETE!', CANVAS_WIDTH / 2, scaleY(130));
                
                ctx.font = `bold ${scaleValue(18)}px Arial`;
                ctx.fillText(`Missiles Left: ${missilesLeft} (Bonus: ${missilesBonus})`, CANVAS_WIDTH / 2, scaleY(160));
                ctx.fillText(`Cities Saved: ${citiesSaved} (Bonus: ${citiesBonus})`, CANVAS_WIDTH / 2, scaleY(190));
                ctx.fillText(`Planes Shot Down: ${planesShotDown}`, CANVAS_WIDTH / 2, scaleY(220));
                ctx.fillText(`Structures Rebuilt: ${reconstructedCount}`, CANVAS_WIDTH / 2, scaleY(250));
                if (spyPlaneBonus > 0) {
                    ctx.fillText(`Spy Plane Bonuses: +${spyPlaneBonus}`, CANVAS_WIDTH / 2, scaleY(280));
                }
                if (stealthPlaneBonusActive) {
                    ctx.fillText(`Stealth Plane Bonus: Double Radius!`, CANVAS_WIDTH / 2, scaleY(310));
                }
                if (cargoPlaneMissileReduction > 0) {
                    ctx.fillText(`Cargo Plane Bonus: -${cargoPlaneEnemyMissileReduction}`, CANVAS_WIDTH / 2, scaleY(340));
                }
                if (killerPlaneImmunityActive) {
                    ctx.fillText(`Killer Plane Bonus: Immunity!`, CANVAS_WIDTH / 2, scaleY(370));
                }
                if (ironBeamActive) {
                    ctx.fillText(`Iron Beam Active: ${ironBeamWavesLeft}`, CANVAS_WIDTH / 2, scaleY(400));
                }

                ctx.fillStyle = '#ff0';
                ctx.fillText('Preparing next level...', CANVAS_WIDTH / 2, scaleY(430));
                
                ctx.textAlign = 'left';
            }

            // Draw end game screen
            function drawEndGame() {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${scaleValue(35)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - scaleY(40));
                
                ctx.font = `bold ${scaleValue(25)}px Arial`;
                ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + scaleY(20));
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('TAP TO PLAY AGAIN', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + scaleY(80));
                
                ctx.textAlign = 'left';
            }

            // Draw cities
            function drawCities() {
                cities.forEach(city => {
                    if(city.active) {
                        city.draw();
                    }
                });
            }

            // Draw anti-missile batteries
            function drawAntiMissileBatteries() {
                antiMissileBatteries.forEach(amb => {
                    if (amb.draw) {
                        amb.draw();
                    }
                });
                
                // Draw Iron Beam Lasers if active
                if (ironBeamActive) {
                    ironBeamLasers.forEach(laser => {
                        laser.draw();
                    });
                }
            }

            // Get score multiplier based on level
            function getMultiplier() {
                return Math.min(6, Math.floor((level + 1) / 2));
            }

            // Draw background with stars and ground
            function drawBackground() {
                // Black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw stars
                ctx.fillStyle = '#fff';
                for(let i = 0; i < 100; i++) {
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = Math.random() * (CANVAS_HEIGHT - GROUND_HEIGHT);
                    const size = Math.random() * 1.5;
                    ctx.fillRect(x, y, size, size);
                }
                
                // Draw ground
                const groundY = CANVAS_HEIGHT - GROUND_HEIGHT;
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);
                ctx.lineTo(0, groundY);
                
                let x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 20 + Math.random() * 30;
                    const heightVariation = Math.random() * 15;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                
                ctx.lineTo(CANVAS_WIDTH, groundY);
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();
                
                // Draw ground details
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.beginPath();
                x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 50 + Math.random() * 50;
                    const heightVariation = Math.random() * 10;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                ctx.stroke();
            }

            // City class with improved graphics
            class City {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.active = true;
                    this.width = scaleValue(60);
                    this.height = scaleValue(40);
                }

                draw() {
                    if(!this.active) return;
                    
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;

                    ctx.fillStyle = '#222';
                    ctx.fillRect(baseX - scaleValue(5), baseY - scaleValue(10), this.width + scaleValue(10), scaleValue(10));
                    ctx.fillStyle = '#555';
                    ctx.fillRect(baseX - scaleValue(2), baseY - scaleValue(12), this.width + scaleValue(4), scaleValue(2)); 

                    const buildingTypes = [
                        { widthFactor: 0.2, heightFactor: 1.2, color: 'hsl(200, 80%, 50%)' },
                        { widthFactor: 0.25, heightFactor: 1.5, color: 'hsl(280, 80%, 60%)' },
                        { widthFactor: 0.22, heightFactor: 1.0, color: 'hsl(160, 70%, 55%)' }
                    ];
                    
                    let currentX = baseX + scaleValue(5);

                    for (let i = 0; i < buildingTypes.length; i++) {
                        const type = buildingTypes[i];
                        const buildingWidth = this.width * type.widthFactor;
                        const buildingHeight = this.height * type.heightFactor;
                        const buildingColor = type.color;

                        ctx.fillStyle = buildingColor;
                        ctx.beginPath();
                        ctx.moveTo(currentX, baseY - scaleValue(10));
                        ctx.lineTo(currentX, baseY - scaleValue(10) - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - scaleValue(10) - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - scaleValue(10));
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = `rgba(0, 255, 255, 0.8)`;
                        ctx.fillRect(currentX + buildingWidth * 0.1, baseY - scaleValue(10) - buildingHeight - scaleValue(3), buildingWidth * 0.8, scaleValue(3));
                        
                        ctx.fillStyle = '#0ff';
                        const panelHeight = scaleValue(5);
                        const panelWidth = buildingWidth * 0.6;
                        for (let r = 0; r < Math.floor(buildingHeight / (panelHeight + scaleValue(8))); r++) {
                            ctx.fillRect(currentX + (buildingWidth - panelWidth) / 2, 
                                         baseY - scaleValue(10) - buildingHeight + scaleValue(5) + r * (panelHeight + scaleValue(8)),
                                         panelWidth, panelHeight);
                        }
                        
                        currentX += buildingWidth + scaleValue(5);
                    }

                    const domeRadius = this.width / 2;
                    const domeCenterX = this.x;
                    const domeCenterY = baseY - this.height * 1.3;

                    let domeGradient;
                    if (citiesImmune || immunityActive) {
                        domeGradient = ctx.createRadialGradient(
                            domeCenterX, domeCenterY - domeRadius / 3, 0,
                            domeCenterX, domeCenterY, domeRadius
                        );
                        domeGradient.addColorStop(0, 'rgba(255, 255, 0, 0.9)');
                        domeGradient.addColorStop(0.8, 'rgba(200, 200, 0, 0.7)');
                        domeGradient.addColorStop(1, 'rgba(150, 150, 0, 0.5)');
                    } else {
                        domeGradient = ctx.createRadialGradient(
                            domeCenterX, domeCenterY - domeRadius / 3, 0,
                            domeCenterX, domeCenterY, domeRadius
                        );
                        domeGradient.addColorStop(0, 'rgba(0, 255, 255, 0.7)');
                        domeGradient.addColorStop(0.8, 'rgba(0, 100, 255, 0.5)');
                        domeGradient.addColorStop(1, 'rgba(0, 50, 150, 0.3)');
                    }

                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.arc(domeCenterX, domeCenterY, domeRadius, Math.PI, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = citiesImmune || immunityActive ? 'rgba(255, 255, 0, 1)' : 'rgba(0, 255, 255, 0.8)';
                    ctx.lineWidth = scaleValue(2);
                    ctx.stroke();

                    ctx.fillStyle = citiesImmune || immunityActive ? '#ffff00' : '#0ff';
                    ctx.beginPath();
                    ctx.arc(domeCenterX - domeRadius * 0.8, domeCenterY, scaleValue(2), 0, Math.PI * 2);
                    ctx.arc(domeCenterX + domeRadius * 0.8, domeCenterY, scaleValue(2), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Anti-missile battery class
            class AntiMissileBattery {
                constructor(x, y, specialAbility) {
                    this.x = x;
                    this.y = y;
                    this.missilesLeft = 10;
                    this.width = scaleValue(60);
                    this.height = scaleValue(50);
                    this.active = true;
                    this.health = 3;
                    this.radarAngle = 0;
                    this.animationFrame = 0;
                    this.specialAbility = specialAbility; // 'immunity', 'explosion', or 'laser'
                    this.specialColor = this.getSpecialColor();
                }
                
                getSpecialColor() {
                    switch(this.specialAbility) {
                        case 'immunity': return '#ffff00'; // Yellow
                        case 'explosion': return '#ff9900'; // Orange
                        case 'laser': return '#00ff00'; // Green
                        default: return '#0ff'; // Cyan
                    }
                }

                hasMissile() {
                    return this.missilesLeft > 0 && this.active;
                }

                draw() {
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;
                    const siloHeight = scaleValue(25);

                    if (!this.active) {
                        // Destroyed state
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.moveTo(baseX, baseY);
                        ctx.lineTo(baseX + this.width, baseY);
                        ctx.lineTo(baseX + this.width - scaleValue(5), baseY - scaleValue(10));
                        ctx.lineTo(baseX + scaleValue(5), baseY - scaleValue(10));
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(baseX + this.width * 0.2, baseY - scaleValue(10));
                        ctx.lineTo(baseX + this.width * 0.8, baseY - scaleValue(10));
                        ctx.lineTo(baseX + this.width * 0.7, baseY - scaleValue(25));
                        ctx.lineTo(baseX + this.width * 0.3, baseY - scaleValue(25));
                        ctx.closePath();
                        ctx.fill();

                        // Some debris
                        ctx.fillStyle = '#222';
                        ctx.fillRect(baseX + scaleValue(10), baseY - scaleValue(20), scaleValue(5), scaleValue(10));
                        ctx.fillRect(baseX + this.width - scaleValue(15), baseY - scaleValue(18), scaleValue(7), scaleValue(8));
                        ctx.fillRect(baseX + this.width / 2 - scaleValue(3), baseY - scaleValue(28), scaleValue(6), scaleValue(12));
                        return;
                    }

                    this.animationFrame++;
                    this.radarAngle = (this.animationFrame * 5) % 360;

                    // Base (Trapezoid)
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.lineTo(baseX + this.width, baseY);
                    ctx.lineTo(baseX + this.width - scaleValue(10), baseY - scaleValue(15));
                    ctx.lineTo(baseX + scaleValue(10), baseY - scaleValue(15));
                    ctx.closePath();
                    ctx.fill();

                    // Main Structure (Hexagon)
                    const hexTopY = baseY - scaleValue(15) - this.height * 0.6;
                    const hexBaseY = baseY - scaleValue(15);
                    const hexWidth = this.width * 0.8;
                    const hexX = this.x;

                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(hexX, hexTopY);
                    ctx.lineTo(hexX + hexWidth / 2, hexBaseY - this.height * 0.3);
                    ctx.lineTo(hexX + hexWidth / 2, hexBaseY);
                    ctx.lineTo(hexX, hexBaseY + this.height * 0.3);
                    ctx.lineTo(hexX - hexWidth / 2, hexBaseY);
                    ctx.lineTo(hexX - hexWidth / 2, hexBaseY - this.height * 0.3);
                    ctx.closePath();
                    ctx.fill();

                    // Inner highlight for hexagon
                    const innerGradient = ctx.createLinearGradient(hexX - hexWidth / 2, hexTopY, hexX + hexWidth / 2, hexTopY);
                    innerGradient.addColorStop(0, '#777');
                    innerGradient.addColorStop(0.5, '#AAA');
                    innerGradient.addColorStop(1, '#777');
                    ctx.strokeStyle = innerGradient;
                    ctx.lineWidth = scaleValue(2);
                    ctx.stroke();

                    // VLS (Vertical Launch System) Silos
                    const siloCount = 4;
                    const siloWidth = scaleValue(8);
                    const siloSpacing = (hexWidth - (siloCount * siloWidth)) / (siloCount + 1);
                    let currentSiloX = hexX - hexWidth / 2 + siloSpacing;

                    for (let i = 0; i < siloCount; i++) {
                        // Silo base
                        ctx.fillStyle = '#333';
                        ctx.fillRect(currentSiloX, hexBaseY - siloHeight, siloWidth, siloHeight);
                        
                        // Missile inside silo
                        if (this.missilesLeft > i) {
                            ctx.fillStyle = this.specialColor;
                            ctx.fillRect(currentSiloX + scaleValue(1), hexBaseY - siloHeight + scaleValue(5), siloWidth - scaleValue(2), siloHeight - scaleValue(8));
                            // Missile tip
                            ctx.beginPath();
                            ctx.moveTo(currentSiloX + siloWidth / 2, hexBaseY - siloHeight + scaleValue(5));
                            ctx.lineTo(currentSiloX + scaleValue(1), hexBaseY - siloHeight + scaleValue(10));
                            ctx.lineTo(currentSiloX + siloWidth - scaleValue(1), hexBaseY - siloHeight + scaleValue(10));
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Silo lines
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = scaleValue(1);
                        ctx.strokeRect(currentSiloX, hexBaseY - siloHeight, siloWidth, siloHeight);

                        currentSiloX += siloWidth + siloSpacing;
                    }

                    // Radar Dome
                    const radarRadius = scaleValue(15);
                    const radarCenterX = this.x;
                    const radarCenterY = hexTopY - radarRadius + scaleValue(5);

                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(radarCenterX, radarCenterY, radarRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Radar arm (animated)
                    ctx.save();
                    ctx.translate(radarCenterX, radarCenterY);
                    ctx.rotate(this.radarAngle * Math.PI / 180);
                    ctx.fillStyle = this.specialColor;
                    ctx.fillRect(0, -scaleValue(1), radarRadius, scaleValue(2));
                    ctx.restore();

                    // Missile count display (digital style)
                    ctx.fillStyle = this.specialColor;
                    ctx.font = `bold ${scaleValue(12)}px "Press Start 2P", cursive, monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.missilesLeft}`, this.x, hexTopY + scaleValue(10));

                    // Health bar
                    if (this.health < 3 && this.active) {
                        const barWidth = this.width * 0.7;
                        const barHeight = scaleValue(5);
                        const barX = this.x - barWidth / 2;
                        const barY = baseY + scaleValue(5);

                        ctx.fillStyle = '#000';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        const healthFillWidth = (this.health / 3) * barWidth;
                        ctx.fillStyle = (this.health === 1) ? 'red' : 'orange';
                        ctx.fillRect(barX, barY, healthFillWidth, barHeight);

                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = scaleValue(1);
                        ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }
                    
                    // Special ability indicator
                    ctx.fillStyle = this.specialColor;
                    ctx.font = `bold ${scaleValue(10)}px Arial`;
                    ctx.textAlign = 'center';
                    
                    let abilityText = '';
                    switch(this.specialAbility) {
                        case 'immunity': abilityText = 'IMMUNITY'; break;
                        case 'explosion': abilityText = 'BOOST'; break;
                        case 'laser': abilityText = 'LASER'; break;
                    }
                    
                    ctx.fillText(abilityText, this.x, baseY + scaleValue(25));
                }
            }

            // Iron Beam Laser class
            class IronBeamLaser {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.width = scaleValue(30);
                    this.height = scaleValue(20);
                    this.active = true;
                    this.animationFrame = 0;
                    this.targetMissile = null;
                    this.beamActive = false;
                    this.beamEndX = 0;
                    this.beamEndY = 0;
                    this.beamWidth = scaleValue(3);
                }

                draw() {
                    if (!this.active) return;
                    
                    this.animationFrame++;
                    
                    // Base
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - this.width / 2, this.y - this.height);
                    ctx.lineTo(this.x + this.width / 2, this.y - this.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Laser emitter (rotating)
                    ctx.save();
                    ctx.translate(this.x, this.y - this.height / 2);
                    
                    // Only rotate if we have a target
                    if (this.targetMissile) {
                        const angle = Math.atan2(this.targetMissile.y - (this.y - this.height / 2), 
                                            this.targetMissile.x - this.x);
                        ctx.rotate(angle);
                    } else {
                        // Gentle idle rotation
                        const idleAngle = Math.sin(this.animationFrame * 0.05) * 0.3;
                        ctx.rotate(idleAngle);
                    }
                    
                    // Emitter
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-scaleValue(5), -scaleValue(2), scaleValue(10), scaleValue(4));
                    
                    // Glowing center
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, scaleValue(5));
                    gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(0, 100, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, scaleValue(5), 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Draw beam if active
                    if (this.beamActive) {
                        const beamGradient = ctx.createLinearGradient(this.x, this.y - this.height / 2, this.beamEndX, this.beamEndY);
                        beamGradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                        beamGradient.addColorStop(0.5, 'rgba(0, 255, 100, 0.6)');
                        beamGradient.addColorStop(1, 'rgba(0, 255, 0, 0)');
                        
                        ctx.strokeStyle = beamGradient;
                        ctx.lineWidth = this.beamWidth;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - this.height / 2);
                        ctx.lineTo(this.beamEndX, this.beamEndY);
                        ctx.stroke();
                        
                        // Add some glow
                        ctx.shadowColor = '#0f0';
                        ctx.shadowBlur = scaleValue(10);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
                
                update() {
                    if (gamePaused) return;
                    
                    // Find closest enemy missile in range
                    if (!this.targetMissile || !this.targetMissile.active || 
                        this.targetMissile.state !== MISSILE.active || 
                        Date.now() - lastBeamActivationTime < BEAM_COOLDOWN) {
                        
                        this.targetMissile = null;
                        this.beamActive = false;
                        
                        // Find new target
                        let closestMissile = null;
                        let closestDistance = scaleValue(200); // Range of the laser
                        
                        enemyMissiles.forEach(missile => {
                            if (missile.state === MISSILE.active) {
                                const dx = missile.x - this.x;
                                const dy = missile.y - (this.y - this.height / 2);
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestMissile = missile;
                                }
                            }
                        });
                        
                        if (closestMissile) {
                            this.targetMissile = closestMissile;
                        }
                    }
                    
                    // Activate beam if we have a target
                    if (this.targetMissile && Date.now() - lastBeamActivationTime >= BEAM_COOLDOWN) {
                        this.beamActive = true;
                        this.beamEndX = this.targetMissile.x;
                        this.beamEndY = this.targetMissile.y;
                        this.beamWidth = scaleValue(3) + Math.sin(this.animationFrame * 0.2) * scaleValue(1);
                        
                        // Check if we've hit the missile
                        const dx = this.beamEndX - this.x;
                        const dy = this.beamEndY - (this.y - this.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < scaleValue(210)) { // Slightly more than range to account for movement
                            // Destroy the missile
                            this.targetMissile.state = MISSILE.exploding;
                            score += 50 * getMultiplier();
                            lastBeamActivationTime = Date.now();
                        }
                    } else {
                        this.beamActive = false;
                    }
                }
            }

            // Base Missile class
            class Missile {
                constructor(options) {
                    this.startX = options.startX;
                    this.startY = options.startY;
                    this.endX = options.endX;
                    this.endY = options.endY;
                    this.color = options.color;
                    this.trailColor = options.trailColor;
                    this.x = options.startX;
                    this.y = options.startY;
                    this.state = MISSILE.active;
                    this.width = scaleValue(3);
                    this.height = scaleValue(3);
                    this.explodeRadius = 0;
                    this.speedFactor = options.speedFactor || 1;
                    this.explosionSizeMultiplier = options.explosionSizeMultiplier || 1;
                }

                draw() {
                    if(this.state === MISSILE.active) {
                        const gradient = ctx.createLinearGradient(this.startX, this.startY, this.x, this.y);
                        gradient.addColorStop(0, this.trailColor);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = scaleValue(1);
                        ctx.beginPath();
                        ctx.moveTo(this.startX, this.startY);
                        ctx.lineTo(this.x, this.y);
                        ctx.stroke();

                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if(this.color === '#0f0') {
                            ctx.shadowColor = this.color;
                            ctx.shadowBlur = scaleValue(10);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    } else if(this.state === MISSILE.exploding || this.state === MISSILE.imploding) {
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.explodeRadius
                        );
                        
                        if(this.state === MISSILE.exploding) {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            gradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.6)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        }
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        explodeOtherMissiles(this, ctx);
                    }
                }

                explode() {
                    const maxRadius = scaleValue(40) * this.explosionSizeMultiplier;
                    const implodeRate = scaleValue(3) * this.speedFactor;
                    const explodeRate = scaleValue(2) * this.speedFactor;

                    if(this.state === MISSILE.exploding) {
                        this.explodeRadius += explodeRate;
                    }
                    if(this.explodeRadius > maxRadius) {
                        this.state = MISSILE.imploding;
                    }
                    if(this.state === MISSILE.imploding) {
                        this.explodeRadius -= implodeRate;
                        if(this.groundExplosion) {
                            if(this.target && this.target[2] instanceof City) {
                                if (!citiesImmune && !immunityActive) {
                                    this.target[2].active = false;
                                    checkAllCitiesDestroyed(); 
                                }
                            } else if (this.target && this.target[2] instanceof AntiMissileBattery) {
                                const targetBattery = this.target[2];
                                if (targetBattery.active) {
                                    targetBattery.health--;
                                    if (targetBattery.health <= 0) {
                                        targetBattery.active = false;
                                        targetBattery.missilesLeft = 0;
                                    }
                                }
                            }
                        }
                    }
                    if(this.explodeRadius < 0) {
                        this.state = MISSILE.exploded;
                    }
                }
            }

            // Player's Missile class
            class PlayerMissile extends Missile {
                constructor(source, endX, endY) {
                    const amb = antiMissileBatteries[source];
                    const speedFactor = (source === 1) ? 1.5 : 1;
                    
                    super({
                        startX: amb.x,
                        startY: amb.y,
                        endX: endX,
                        endY: endY,
                        color: amb.specialColor,
                        trailColor: 'rgba(0, 255, 255, 0.7)',
                        speedFactor: speedFactor,
                        explosionSizeMultiplier: stealthPlaneExplosionBonus
                    });

                    const xDistance = this.endX - this.startX;
                    const yDistance = this.endY - this.startY;
                    
                    const distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
                    const distancePerFrame = scaleValue(15) * this.speedFactor;
                    const scale = distance / distancePerFrame;

                    this.dx = xDistance / scale;
                    this.dy = yDistance / scale;
                    amb.missilesLeft--;
                }

                update() {
                    if(this.state === MISSILE.active && this.y <= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                    } else {
                        this.explode();
                    }
                }
            }

            // Player shoot function
            function playerShoot(clientX, clientY) {
                if (gamePaused) return;
                
                const rect = canvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;

                if(canvasY >= scaleY(50) && canvasY <= CANVAS_HEIGHT - GROUND_HEIGHT - scaleY(50)) {
                    const source = whichAntiMissileBattery(canvasX);
                    if(source === -1) return;
                    
                    playerMissiles.push(new PlayerMissile(source, canvasX, canvasY));
                }
            }

            // Enemy's Missile class
            class EnemyMissile extends Missile {
                constructor(targets, isFast = false, waveSpeedFactor = 1, isFromPlane = false, planeX = 0, planeY = 0) {
                    let startX, startY;
                    if (isFromPlane) {
                        startX = planeX;
                        startY = planeY;
                    } else {
                        startX = rand(0, CANVAS_WIDTH);
                        startY = 0;
                    }
                    
                    const speedFactor = (isFast ? 1.5 : 1) * waveSpeedFactor;
                    const target = targets[rand(0, targets.length - 1)];
                    
                    super({
                        startX: startX,
                        startY: startY,
                        endX: target[0],
                        endY: target[1],
                        color: '#f00',
                        trailColor: 'rgba(255, 100, 100, 0.5)',
                        speedFactor: speedFactor
                    });

                    let baseSpeed = scaleValue(800);
                    baseSpeed = Math.max(scaleValue(150), baseSpeed - (level * scaleValue(50))); 
                    
                    const framesToTarget = (baseSpeed * (0.4 + Math.random() * 1.2)) / this.speedFactor; 

                    this.dx = (this.endX - this.startX) / framesToTarget;
                    this.dy = (this.endY - this.startY) / framesToTarget;
                    this.target = target;
                    
                    this.delay = isFromPlane ? 0 : rand(0, Math.max(10, 60 - level));
                    this.groundExplosion = false;
                }

                update() {
                    if (gamePaused) return;
                    
                    if(this.delay) {
                        this.delay--;
                        return;
                    }
                    
                    if(this.state === MISSILE.active && this.y >= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                        this.groundExplosion = true;
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                        
                        if(Math.random() < 0.1) {
                            this.x += (Math.random() - 0.5) * scaleValue(3);
                        }
                    } else {
                        this.explode();
                    }
                }
            }

            // Enemy Plane class
            class EnemyPlane {
                constructor() {
                    this.width = scaleValue(70);
                    this.height = scaleValue(25);
                    this.y = rand(scaleY(50), CANVAS_HEIGHT / 3);
                    this.speed = rand(2, 4) * (1 + level * 0.1);
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.missileLaunchCooldown = 60;
                    this.currentMissileCooldown = rand(10, this.missileLaunchCooldown);
                    this.missilesToLaunch = rand(1, 3);
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 20)), this.y + 15 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 15)), this.y + 5 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 5)), this.y - 15 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Cockpit
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.arc(this.x - (this.direction * this.width * 0.1), this.y, scaleValue(5), 0, Math.PI * 2);
                    ctx.fill();
                }

                update() {
                    if (gamePaused) return;
                    
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += scaleValue(2);
                            if (this.explodeRadius > scaleValue(80)) {
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Launch missiles
                    if (this.missilesToLaunch > 0) {
                        this.currentMissileCooldown--;
                        if (this.currentMissileCooldown <= 0) {
                            const targets = viableTargets();
                            if (targets.length > 0) {
                                enemyMissiles.push(new EnemyMissile(targets, true, 1.2, true, this.x, this.y));
                                this.missilesToLaunch--;
                            }
                            this.currentMissileCooldown = rand(30, this.missileLaunchCooldown);
                        }
                    }

                    // Remove plane if it goes off-screen and has finished launching missiles
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 500 * getMultiplier();
                    planesShotDownThisLevel++;
                    checkPlaneReconstructionBonus();
                }
            }

            // Spy Plane class
            class SpyPlane {
                constructor() {
                    this.width = scaleValue(50);
                    this.height = scaleValue(18);
                    this.y = rand(scaleY(80), CANVAS_HEIGHT / 3 - scaleY(30));
                    this.speed = rand(3, 5) * (1 + level * 0.05);
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(200, 200, 200, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(100, 100, 100, 0.7)');
                            gradient.addColorStop(1, 'rgba(50, 50, 50, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 15)), this.y + 10 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 10)), this.y + 3 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 3)), this.y - 10 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Small antenna/sensor on top
                    ctx.fillStyle = '#888';
                    ctx.fillRect(this.x - (this.direction * this.width * 0.2), this.y - this.height / 2 - scaleValue(5), scaleValue(2), scaleValue(5));
                }

                update() {
                    if (gamePaused) return;
                    
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += scaleValue(1.5);
                            if (this.explodeRadius > scaleValue(60)) {
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 750 * getMultiplier();
                    spyPlaneWaveMissileBonus += 2;
                    extraMissilesFromSpyPlane += 2;
                }
            }

            // Stealth Plane class
            class StealthPlane {
                constructor() {
                    this.width = scaleValue(60);
                    this.height = scaleValue(20);
                    this.y = rand(scaleY(100), CANVAS_HEIGHT / 3 - scaleY(50));
                    this.speed = rand(4, 6) * (1 + level * 0.08);
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(100, 100, 150, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(50, 50, 100, 0.7)');
                            gradient.addColorStop(1, 'rgba(20, 20, 50, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    // Stealth shape (simple triangle/delta wing)
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Glare effect to suggest stealth/reflection
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x - (this.direction * this.width), this.y);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Outline (subtle)
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = scaleValue(1);
                    ctx.stroke();
                }

                update() {
                    if (gamePaused) return;
                    
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += scaleValue(1.8);
                            if (this.explodeRadius > scaleValue(70)) {
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 1000 * getMultiplier();
                    stealthPlaneExplosionBonus = 2;
                }
            }

            // Cargo Plane class
            class CargoPlane {
                constructor() {
                    this.width = scaleValue(90);
                    this.height = scaleValue(35);
                    this.y = rand(scaleY(120), CANVAS_HEIGHT / 2.5);
                    this.speed = rand(1, 2) * (1 + level * 0.05);
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 150, 0, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(150, 75, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(100, 50, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#8B4513';
                    // Main body
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.1), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2 + scaleValue(5));
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2 - scaleValue(5));
                    ctx.closePath();
                    ctx.fill();

                    // Tail fin
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.9 + 5)), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.9 - 5)), this.y - this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings (larger and more pronounced)
                    ctx.fillStyle = '#777';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 40)), this.y + 20 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 30)), this.y + 10 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 10)), this.y - 20 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Windows or cargo markings
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                    for(let i = 0; i < 3; i++) {
                        ctx.fillRect(this.x - (this.direction * (this.width * 0.2 + i * 15)), this.y - scaleValue(5), scaleValue(5), scaleValue(10));
                    }
                }

                update() {
                    if (gamePaused) return;
                    
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += scaleValue(1.2);
                            if (this.explodeRadius > scaleValue(90)) {
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 1200 * getMultiplier();
                    cargoPlaneEnemyMissileReduction = Math.min(2 * level, cargoPlaneEnemyMissileReduction + 2); 
                }
            }

            // Killer Plane class
            class KillerPlane {
                constructor() {
                    this.width = scaleValue(80);
                    this.height = scaleValue(30);
                    this.y = rand(scaleY(70), CANVAS_HEIGHT / 3 - scaleY(10));
                    this.speed = rand(2.5, 4.5) * (1 + level * 0.12);
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.missileLaunchCooldown = 30;
                    this.currentMissileCooldown = rand(5, this.missileLaunchCooldown);
                    this.missilesToLaunch = rand(2, 6);
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 50, 0, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(200, 0, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#304030';
                    // Main body
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.8), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2 + scaleValue(5));
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2 - scaleValue(5));
                    ctx.lineTo(this.x - (this.direction * this.width * 0.8), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings (sharp, camouflaged)
                    ctx.fillStyle = '#203020';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.3), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 + 30)), this.y + 18 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 + 20)), this.y + 8 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 - 8)), this.y - 18 * this.direction);
                    ctx.closePath();
                    ctx.fill();

                    // Cockpit/Sensor (subtle red glow)
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(this.x - (this.direction * this.width * 0.15), this.y, scaleValue(4), 0, Math.PI * 2);
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = scaleValue(8);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                update() {
                    if (gamePaused) return;
                    
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += scaleValue(2.5);
                            if (this.explodeRadius > scaleValue(100)) {
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Launch missiles
                    if (this.missilesToLaunch > 0) {
                        this.currentMissileCooldown--;
                        if (this.currentMissileCooldown <= 0) {
                            const targets = viableTargets();
                            if (targets.length > 0) {
                                enemyMissiles.push(new EnemyMissile(targets, true, 1.5, true, this.x, this.y));
                                this.missilesToLaunch--;
                            }
                            this.currentMissileCooldown = rand(15, this.missileLaunchCooldown);
                        }
                    }

                    // Remove plane if it goes off-screen and has finished launching missiles
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 2000 * getMultiplier();
                    citiesImmune = true;
                }
            }

            // Explode other missiles in radius
            function explodeOtherMissiles(missile, ctx) {
                if(!missile.groundExplosion) {
                    enemyMissiles.forEach(otherMissile => {
                        const distance = Math.sqrt(
                            Math.pow(missile.x - otherMissile.x, 2) +
                            Math.pow(missile.y - otherMissile.y, 2)
                        );
                        if(distance < missile.explodeRadius && otherMissile.state === MISSILE.active) {
                            score += 25 * getMultiplier();
                            otherMissile.state = MISSILE.exploding;
                        }
                    });

                    // Check if the player missile's explosion hits the enemy plane
                    if (enemyPlane && enemyPlane.active) {
                        const distanceToPlane = Math.sqrt(
                            Math.pow(missile.x - enemyPlane.x, 2) +
                            Math.pow(missile.y - enemyPlane.y, 2)
                        );
                        if (distanceToPlane < missile.explodeRadius + scaleValue(20)) { 
                            enemyPlane.hit();
                            enemyPlane = null;
                        }
                    }

                    // Check if the player missile's explosion hits the spy plane
                    if (spyPlane && spyPlane.active) {
                        const distanceToSpyPlane = Math.sqrt(
                            Math.pow(missile.x - spyPlane.x, 2) +
                            Math.pow(missile.y - spyPlane.y, 2)
                        );
                        if (distanceToSpyPlane < missile.explodeRadius + scaleValue(15)) {
                            spyPlane.hit();
                            spyPlane = null;
                        }
                    }

                    // Check if the player missile's explosion hits the stealth plane
                    if (stealthPlane && stealthPlane.active) {
                        const distanceToStealthPlane = Math.sqrt(
                            Math.pow(missile.x - stealthPlane.x, 2) +
                            Math.pow(missile.y - stealthPlane.y, 2)
                        );
                        if (distanceToStealthPlane < missile.explodeRadius + scaleValue(10)) {
                            stealthPlane.hit();
                            stealthPlane = null;
                        }
                    }

                    // Check if the player missile's explosion hits the cargo plane
                    if (cargoPlane && cargoPlane.active) {
                        const distanceToCargoPlane = Math.sqrt(
                            Math.pow(missile.x - cargoPlane.x, 2) +
                            Math.pow(missile.y - cargoPlane.y, 2)
                        );
                        if (distanceToCargoPlane < missile.explodeRadius + scaleValue(25)) {
                            cargoPlane.hit();
                            cargoPlane = null;
                        }
                    }

                    // Check if the player missile's explosion hits the killer plane
                    if (killerPlane && killerPlane.active) {
                        const distanceToKillerPlane = Math.sqrt(
                            Math.pow(missile.x - killerPlane.x, 2) +
                            Math.pow(missile.y - killerPlane.y, 2)
                        );
                        if (distanceToKillerPlane < missile.explodeRadius + scaleValue(20)) {
                            killerPlane.hit();
                            killerPlane = null;
                        }
                    }
                }
            }

            // Función para verificar el bonus de reconstrucción de avión
            function checkPlaneReconstructionBonus() {
                if (planesShotDownThisLevel >= 3) {
                    reconstructRandomDestroyedStructure();
                    planesShotDownThisLevel = 0;
                }
            }

            // Función para reconstruir una estructura aleatoria destruida
            function reconstructRandomDestroyedStructure() {
                const destroyedCities = cities.filter(city => !city.active);
                const destroyedBatteries = antiMissileBatteries.filter(battery => !battery.active);

                const allDestroyed = [...destroyedCities, ...destroyedBatteries];

                if (allDestroyed.length > 0) {
                    const structureToRebuild = allDestroyed[rand(0, allDestroyed.length - 1)];
                    if (structureToRebuild instanceof City) {
                        structureToRebuild.active = true;
                        reconstructedCount++;
                    } else if (structureToRebuild instanceof AntiMissileBattery) {
                        structureToRebuild.active = true;
                        structureToRebuild.health = 3;
                        structureToRebuild.missilesLeft = 10;
                        reconstructedCount++;
                    }
                }
            }

            // Get viable targets for enemy missiles
            function viableTargets() {
                const targets = [];

                // If cities are immune, enemy missiles can only target batteries
                if (citiesImmune || immunityActive) {
                    antiMissileBatteries.forEach(amb => {
                        if (amb.active) {
                            targets.push([amb.x, amb.y - amb.height, amb]);
                        }
                    });
                    if (targets.length === 0) {
                        targets.push([rand(0, CANVAS_WIDTH), CANVAS_HEIGHT - GROUND_HEIGHT + scaleValue(10), null]);
                    }
                } else {
                    cities.forEach(city => {
                        if(city.active) {
                            targets.push([city.x, city.y - city.height + scaleValue(10), city]);
                        }
                    });

                    while(targets.length > 3) {
                        targets.splice(rand(0, targets.length - 1), 1);
                    }

                    if(Math.random() < (level * 0.05)) { 
                        antiMissileBatteries.forEach(amb => {
                            if (amb.active) { 
                                targets.push([amb.x, amb.y - amb.height, amb]);
                            }
                        });
                    }
                }
                
                return targets;
            }

            // Game loop
            function nextFrame() {
                if (gamePaused) {
                    drawGameState();
                    drawPausedGame();
                    return;
                }
                
                drawGameState();
                updateEnemyMissiles();
                drawEnemyMissiles();
                updatePlayerMissiles();
                drawPlayerMissiles();

                // Update and draw the enemy plane if active
                if (enemyPlane && enemyPlane.active) {
                    enemyPlane.update();
                    enemyPlane.draw();
                } else if (enemyPlane && enemyPlane.exploded) {
                    enemyPlane.update();
                    enemyPlane.draw();
                }

                // Update and draw the spy plane if active
                if (spyPlane && spyPlane.active) {
                    spyPlane.update();
                    spyPlane.draw();
                } else if (spyPlane && spyPlane.exploded) {
                    spyPlane.update();
                    spyPlane.draw();
                }

                // Update and draw the stealth plane if active
                if (stealthPlane && stealthPlane.active) {
                    stealthPlane.update();
                    stealthPlane.draw();
                } else if (stealthPlane && stealthPlane.exploded) { 
                    stealthPlane.update();
                    stealthPlane.draw();
                }

                // Update and draw the cargo plane if active
                if (cargoPlane && cargoPlane.active) {
                    cargoPlane.update();
                    cargoPlane.draw();
                } else if (cargoPlane && cargoPlane.exploded) { 
                    cargoPlane.update();
                    cargoPlane.draw();
                }

                // Update and draw the killer plane if active
                if (killerPlane && killerPlane.active) {
                    killerPlane.update();
                    killerPlane.draw();
                } else if (killerPlane && killerPlane.exploded) { 
                    killerPlane.update();
                    killerPlane.draw();
                }
                
                // Update and draw Iron Beam Lasers if active
                if (ironBeamActive) {
                    ironBeamLasers.forEach(laser => {
                        laser.update();
                        laser.draw();
                    });
                }
                
                // Check if wave ended (considering all planes)
                if (waveActive && enemyMissiles.length === 0 && 
                    (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded) && 
                    (!spyPlane || !spyPlane.active && !spyPlane.exploded) && 
                    (!stealthPlane || !stealthPlane.active && !stealthPlane.exploded) &&
                    (!cargoPlane || !cargoPlane.active && !cargoPlane.exploded) &&
                    (!killerPlane || !killerPlane.active && !killerPlane.exploded)
                ) {
                    waveActive = false;
                    stopLevel();
                    setTimeout(() => {
                        citiesImmune = false;
                        if (currentWave < WAVES_PER_LEVEL) { 
                            startNextWave();
                        } else { 
                            checkEndLevel(); 
                        }
                    }, 3000);
                }
            }

            // Draw paused game screen
            function drawPausedGame() {
                pauseScreen.style.display = 'flex';
            }

            // Spawns an enemy plane
            function spawnEnemyPlane() {
                if (!enemyPlane && planesPerLevel < MAX_PLANES_PER_LEVEL) {
                    if (Math.random() < 0.3 + (level * 0.05)) {
                        setTimeout(() => {
                            enemyPlane = new EnemyPlane();
                            planesPerLevel++;
                        }, rand(2000, 5000));
                    }
                }
            }

            // Spawns a spy plane
            function spawnSpyPlane() {
                if (!spyPlane && spyPlanesAppearedThisLevel < MAX_SPY_PLANES_PER_LEVEL) {
                    if (Math.random() < 0.15 + (level * 0.02)) {
                        setTimeout(() => {
                            spyPlane = new SpyPlane();
                            spyPlanesAppearedThisLevel++;
                        }, rand(4000, 8000));
                    }
                }
            }

            // Spawns a stealth plane
            function spawnStealthPlane() {
                if (currentWave >= 5 && currentWave <= 10 && !stealthPlane && !stealthPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.20) {
                        setTimeout(() => {
                            stealthPlane = new StealthPlane();
                            stealthPlaneSpawnedThisLevel = true;
                        }, rand(4000, 7000)); 
                    }
                }
            }

            // Spawns a cargo plane
            function spawnCargoPlane() {
                if (currentWave >= 2 && currentWave <= 6 && !cargoPlane && !cargoPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.30) {
                        setTimeout(() => {
                            cargoPlane = new CargoPlane();
                            cargoPlaneSpawnedThisLevel = true;
                        }, rand(5000, 9000)); 
                    }
                }
            }

            // Spawns a Killer Plane
            function spawnKillerPlane() {
                if (currentWave >= 6 && currentWave <= 10 && !killerPlane && !killerPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.25) {
                        setTimeout(() => {
                            killerPlane = new KillerPlane();
                            killerPlaneSpawnedThisLevel = true;
                        }, rand(6000, 10000)); 
                    }
                }
            }

            // Check for end of level
            function checkEndLevel() {
                if(enemyMissiles.length === 0 && 
                    (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded) && 
                    (!spyPlane || !spyPlane.active && !spyPlane.exploded) && 
                    (!stealthPlane || !stealthPlane.active && !stealthPlane.exploded) &&
                    (!cargoPlane || !cargoPlane.active && !cargoPlane.exploded) &&
                    (!killerPlane || !killerPlane.active && !killerPlane.exploded)
                ) {
                    stopLevel();
                    gameContainer.removeEventListener('click', handleTap);
                    gameContainer.removeEventListener('touchend', handleTap);
                    crosshair.style.display = 'none';
                    
                    const missilesLeft = totalMissilesLeft();
                    const citiesSaved = totalCitiesSaved();

                    if(citiesSaved === 0) {
                        endGame(missilesLeft);
                    } else {
                        endLevel(missilesLeft, citiesSaved, planesShotDownThisLevel, reconstructedCount, spyPlaneWaveMissileBonus, stealthPlaneExplosionBonus === 2, cargoPlaneEnemyMissileReduction, citiesImmune);
                    }
                }
            }

            // Function to check if all cities have been destroyed
            function checkAllCitiesDestroyed() {
                if (totalCitiesSaved() === 0) {
                    stopLevel();
                    gameContainer.removeEventListener('click', handleTap);
                    gameContainer.removeEventListener('touchend', handleTap);
                    crosshair.style.display = 'none';
                    endGame(totalMissilesLeft());
                }
            }

            // Handle end of level
            function endLevel(missilesLeft, citiesSaved, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthBonusActive, cargoMissileReduction, killerPlaneImmunityActive) {
                const missilesBonus = missilesLeft * 5 * getMultiplier();
                const citiesBonus = citiesSaved * 100 * getMultiplier();

                drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthBonusActive, cargoMissileReduction, killerPlaneImmunityActive);

                setTimeout(() => {
                    score += missilesBonus + citiesBonus;
                }, 2000);

                setTimeout(setupNextLevel, 4000);
            }

            // Setup next level
            function setupNextLevel() {
                const previousScore = score;
                level++; 
                planesPerLevel = 0;
                planesShotDownThisLevel = 0;
                reconstructedCount = 0;
                spyPlanesAppearedThisLevel = 0;
                spyPlaneWaveMissileBonus = 0;
                extraMissilesFromSpyPlane = 0;
                stealthPlanesAppearedThisLevel = 0;
                stealthPlaneExplosionBonus = 1;
                stealthPlaneSpawnedThisLevel = false;
                cargoPlanesAppearedThisLevel = 0;
                cargoPlaneEnemyMissileReduction = 0;
                cargoPlaneSpawnedThisLevel = false;
                killerPlanesAppearedThisLevel = 0;
                citiesImmune = false;
                killerPlaneSpawnedThisLevel = false;
                immunityActive = false;
                immunityWavesLeft = 0;
                explosionBoostActive = false;
                explosionBoostWavesLeft = 0;
                enemyReductionActive = false;
                enemyReductionWavesLeft = 0;
                powerUpUsedThisLevel = {
                    immunity: false,
                    explosion: false,
                    reduction: false
                };

                // LEVEL 1 TO 2 REWARD LOGIC
                if (level === 2 && totalCitiesSaved() === 6) {
                    bonusMissilesForNextWave = 10; 
                }

                // NEW LOGIC: Rebuild a city if level score was > 3000
                if (previousScore >= 3000) {
                    const destroyedCities = cities.filter(city => !city.active);
                    if (destroyedCities.length > 0) {
                        const cityToRebuild = destroyedCities[rand(0, destroyedCities.length - 1)];
                        cityToRebuild.active = true;
                        reconstructedCount++;
                    }
                }

                // Rebuild and repair all batteries for the new level
                antiMissileBatteries.forEach(amb => {
                    amb.active = true;
                    amb.health = 3;
                });

                initializeLevel(); 
                gameContainer.addEventListener('click', handleTap);
                gameContainer.addEventListener('touchend', handleTap);
                crosshair.style.display = 'block';
            }

            // Handle end of game
            function endGame(missilesLeft) {
                score += missilesLeft * 5 * getMultiplier();
                drawEndGame();
                
                const resetGame = () => {
                    document.removeEventListener('click', resetGame);
                    document.removeEventListener('touchend', resetGame);
                    location.reload(); 
                };
                
                document.addEventListener('click', resetGame);
                document.addEventListener('touchend', resetGame);
            }

            // Get total missiles left
            function totalMissilesLeft() {
                return antiMissileBatteries.filter(amb => amb.active).reduce((total, amb) => total + amb.missilesLeft, 0);
            }

            // Get total cities saved
            function totalCitiesSaved() {
                return cities.filter(city => city.active).length;
            }

            // Update enemy missiles
            function updateEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.update());
                enemyMissiles = enemyMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw enemy missiles
            function drawEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.draw());
            }

            // Update player missiles
            function updatePlayerMissiles() {
                playerMissiles.forEach(missile => missile.update());
                playerMissiles = playerMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw player missiles
            function drawPlayerMissiles() {
                playerMissiles.forEach(missile => missile.draw());
            }

            // Stop level animation
            function stopLevel() {
                cancelAnimationFrame(timerID);
            }

            // Start level animation
            function startLevel() {
                gameStarted = true;
                const animate = () => {
                    nextFrame();
                    timerID = requestAnimationFrame(animate);
                };
                animate();
            }

            // Determine which anti-missile battery to use
            function whichAntiMissileBattery(x) {
                const getUsableBattery = (indices) => {
                    for (const index of indices) {
                        if (antiMissileBatteries[index].hasMissile()) {
                            return index;
                        }
                    }
                    return -1;
                };

                if(!antiMissileBatteries.some(amb => amb.hasMissile())) {
                    return -1;
                }

                if(x <= CANVAS_WIDTH / 3) {
                    return getUsableBattery([0, 1, 2]);
                } else if(x <= (2 * CANVAS_WIDTH / 3)) {
                    if(antiMissileBatteries[1].hasMissile()) return 1;
                    return (x <= CANVAS_WIDTH / 2) ? getUsableBattery([0, 2]) : getUsableBattery([2, 0]);
                } else {
                    return getUsableBattery([2, 1, 0]);
                }
            }

            // Handle mouse move to update target crosshair position
            function handleMouseMove(event) {
                const rect = canvas.getBoundingClientRect();
                targetCrosshairX = event.clientX - rect.left;
                targetCrosshairY = event.clientY - rect.top;
            }
            
            // Handle touch move
            function handleTouchMove(event) {
                event.preventDefault();
                if (event.touches.length > 0) {
                    const touch = event.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    targetCrosshairX = touch.clientX - rect.left;
                    targetCrosshairY = touch.clientY - rect.top;
                }
            }

            // Toggle pause function
            function togglePause() {
                gamePaused = !gamePaused;
                if (gamePaused) {
                    pauseScreen.style.display = 'flex';
                    stopLevel();
                } else {
                    pauseScreen.style.display = 'none';
                    startLevel();
                }
            }

            // Activate city immunity power-up
            function activateImmunity() {
                if (!powerUpUsedThisLevel.immunity) {
                    immunityActive = true;
                    immunityWavesLeft = 3;
                    citiesImmune = true;
                    powerUpUsedThisLevel.immunity = true;
                    showTooltip("Immunity activated! (3 waves)", scaleX(50), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                } else {
                    showTooltip("Immunity already used!", scaleX(50), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                }
            }

            // Activate explosion boost power-up
            function activateExplosionBoost() {
                if (!powerUpUsedThisLevel.explosion) {
                    explosionBoostActive = true;
                    explosionBoostWavesLeft = 5;
                    stealthPlaneExplosionBonus = 2;
                    powerUpUsedThisLevel.explosion = true;
                    showTooltip("Explosion boost activated! (5 waves)", scaleX(400), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                } else {
                    showTooltip("Boost already used!", scaleX(400), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                }
            }
            
            // Activate Iron Beam Laser
            function activateIronBeam() {
                if (!ironBeamActive) {
                    ironBeamActive = true;
                    ironBeamWavesLeft = 7;
                    ironBeamLasers = [
                        new IronBeamLaser(scaleX(350), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT)),
                        new IronBeamLaser(scaleX(450), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT))
                    ];
                    showTooltip("Iron Beam activated! (7 waves)", scaleX(750), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                } else {
                    showTooltip("Laser already active!", scaleX(750), scaleY(CANVAS_HEIGHT - GROUND_HEIGHT));
                }
            }

            return {
                initialize,
                setupListeners
            };
        })();

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            missileCommand.initialize();
            missileCommand.setupListeners();
        });
    </script>
</body>
</html>
