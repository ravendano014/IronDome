<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Iron Dome Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #111;
            display: flex;
            flex-direction: column; /* Alinea el título y el juego en columna */
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: none; /* Ocultar el cursor del sistema para usar nuestro crosshair */
        }

        .game-container {
            position: relative;
            background-color: #000;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            width: 800px; /* Vuelve al ancho fijo */
            height: 600px; /* Vuelve al alto fijo */
        }

        canvas {
            display: block; /* Asegura que no haya espacio extra debajo del canvas */
        }

        .crosshair {
            position: absolute;
            width: 30px; /* Vuelve al tamaño fijo del crosshair */
            height: 30px; /* Vuelve al tamaño fijo del crosshair */
            border: 2px solid lime;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            display: none; /* Inicialmente oculto */
        }

        h1 {
            color: #0ff;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 36px;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 10px;
        }

        /* Estilos para la pantalla de inicio */
        #splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Fondo oscuro semitransparente */
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1001; /* Asegura que esté por encima del juego */
            font-family: 'Arial', sans-serif;
            cursor: pointer; /* Indica que es clickeable */
        }

        #splash-screen h2 {
            color: #0ff;
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #0ff;
        }

        #splash-screen p {
            font-size: 1.5em;
            margin: 5px 0;
            color: #eee;
            max-width: 70%; /* Limita el ancho del texto */
        }

        #splash-screen .click-to-start {
            margin-top: 40px;
            font-size: 2em;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            animation: pulse 1.5s infinite alternate; /* Animación de pulsación */
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div>
        <h1>Iron Dome Enhanced</h1>
        <div class="game-container">
            <canvas width="800" height="600"></canvas>
            <div class="crosshair"></div>
            
            <div id="splash-screen">
                <h2>Iron Dome Enhanced</h2>
                <p>Defend your cities from the enemy missile rain!</p>
                <p>Move the mouse to aim and click to launch a defensive missile.</p>
                <p>Each battery has limited missiles, use them strategically!</p>
                <p>Press 'S' to toggle sound ON/OFF.</p>
                <p class="click-to-start">Click anywhere to start</p>
            </div>
        </div>
    </div>

    <script>
        // Iron Dome Enhanced
        const missileCommand = (function() {
            const canvas = document.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            const gameContainer = document.querySelector('.game-container');
            const crosshair = document.querySelector('.crosshair');
            const splashScreen = document.getElementById('splash-screen');

            // Constants
            const CANVAS_WIDTH = 800;
            const CANVAS_HEIGHT = 600;
            const GROUND_HEIGHT = 100; // Fixed ground height
            const WAVES_PER_LEVEL = 10; // Each level will have 10 waves

            const MISSILE = {
                active: 1,
                exploding: 2,
                imploding: 3,
                exploded: 4
            };

            // Variables
            let score = 0;
            let level = 1;
            let cities = [];
            let antiMissileBatteries = [];
            let playerMissiles = [];
            let enemyMissiles = [];
            let timerID;
            let gameStarted = false;
            let soundEnabled = false; // Inicialmente deshabilitado

            let currentWave = 0;
            let waveActive = false;

            let targetCrosshairX = 0;
            let targetCrosshairY = 0;
            let currentCrosshairX = 0;
            let currentCrosshairY = 0;
            const smoothingFactor = 0.15;
            
            let bonusMissilesForNextWave = 0;
            let planesShotDownThisLevel = 0; // NUEVO: Contador de aviones derribados en el nivel actual

            // Enemy Plane
            let enemyPlane = null;
            let planesPerLevel = 0; // Counter for planes that have appeared in the current level
            const MAX_PLANES_PER_LEVEL = 10; // Maximum planes per level

            // Initialize game
            function initialize() {
                // Set canvas dimensions explicitly (already set in HTML but good practice)
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;

                // Reset game state for a new game
                cities = [];
                antiMissileBatteries = [];
                playerMissiles = [];
                enemyMissiles = [];
                score = 0;
                level = 1;
                currentWave = 0;
                waveActive = false;
                gameStarted = false;
                bonusMissilesForNextWave = 0; // Reset bonus at game start
                enemyPlane = null; // Reset plane
                planesPerLevel = 0; // Reset plane counter
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados

                // Create cities
                cities.push(new City(100, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(200, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(300, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(500, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(600, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(700, CANVAS_HEIGHT - GROUND_HEIGHT + 20));

                // Create anti-missile batteries
                antiMissileBatteries.push(new AntiMissileBattery(50, CANVAS_HEIGHT - GROUND_HEIGHT));
                antiMissileBatteries.push(new AntiMissileBattery(400, CANVAS_HEIGHT - GROUND_HEIGHT));
                antiMissileBatteries.push(new AntiMissileBattery(750, CANVAS_HEIGHT - GROUND_HEIGHT));
                
                // Draw initial state (including splash screen)
                drawGameState(); 
                // Do NOT call initializeLevel or startLevel here. It will be called after splash screen click.
            }

            // Setup event listeners
            function setupListeners() {
                splashScreen.addEventListener('click', () => {
                    if (!gameStarted) {
                        splashScreen.style.display = 'none';
                        gameStarted = true;
                        initializeLevel();
                        gameContainer.addEventListener('click', handleShoot);
                        gameContainer.addEventListener('mousemove', handleMouseMove);
                        crosshair.style.display = 'block';
                    }
                });
                document.addEventListener('keydown', handleKeyPress);
            }

            // Initialize level
            function initializeLevel() {
                playerMissiles = [];
                enemyMissiles = [];
                currentWave = 0; 
                enemyPlane = null; // Ensure no active plane at level start
                planesPerLevel = 0; // Reset plane counter per level
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados por nivel
                startNextWave(); 
            }

            // Start next wave
            function startNextWave() {
                currentWave++;
                if (currentWave > WAVES_PER_LEVEL) {
                    checkEndLevel(); 
                    return;
                }

                const initialMissiles = 10; // Starting missiles for each battery
                
                let missilesForThisWave = initialMissiles;
                if (level === 2 && currentWave === 1 && bonusMissilesForNextWave > 0) {
                    missilesForThisWave += bonusMissilesForNextWave;
                    bonusMissilesForNextWave = 0; 
                }

                const reductionPerTwoWaves = Math.floor((currentWave - 1) / 2);
                antiMissileBatteries.forEach(amb => {
                    // Only reload missiles if the battery is active
                    if (amb.active) { 
                        amb.missilesLeft = Math.max(0, missilesForThisWave - reductionPerTwoWaves); 
                    } else {
                        amb.missilesLeft = 0; // Ensure no missiles if destroyed
                    }
                });

                waveActive = true;
                createEnemyMissiles();
                // Call spawnEnemyPlane after creating missiles, so it appears between waves
                spawnEnemyPlane(); 
                drawGameState(); 
                startLevel(); 
            }

            // Create enemy missiles with increasing difficulty
            function createEnemyMissiles() {
                const targets = viableTargets();
                let numMissiles;
                let baseSpeedFactor;

                numMissiles = 5 + (level * 2) + Math.floor(currentWave * 0.5); 
                baseSpeedFactor = 1 - (level * 0.05) - (currentWave * 0.01); 
                baseSpeedFactor = Math.max(0.2, baseSpeedFactor); 

                if (level === 1) {
                     switch (currentWave) {
                        case 1: numMissiles = 5; baseSpeedFactor = 0.8; break;
                        case 2: numMissiles = 7; baseSpeedFactor = 0.75; break;
                        case 3: numMissiles = 9; baseSpeedFactor = 0.7; break;
                        case 4: numMissiles = 11; baseSpeedFactor = 0.65; break;
                        case 5: numMissiles = 13; baseSpeedFactor = 0.6; break;
                        case 6: numMissiles = 15; baseSpeedFactor = 0.55; break;
                        case 7: numMissiles = 17; baseSpeedFactor = 0.5; break;
                        case 8: numMissiles = 19; baseSpeedFactor = 0.45; break;
                        case 9: numMissiles = 21; baseSpeedFactor = 0.4; break;
                        case 10: numMissiles = 25; baseSpeedFactor = 0.35; break;
                    }
                }


                for(let i = 0; i < numMissiles; i++) {
                    const isFast = Math.random() < 0.3; 
                    enemyMissiles.push(new EnemyMissile(targets, isFast, baseSpeedFactor));
                }
            }

            // Random number helper
            function rand(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // Draw game state
            function drawGameState() {
                drawBackground();
                drawCities();
                drawAntiMissileBatteries();
                drawScore();
                drawLevel();
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Wave: ${currentWave}/${WAVES_PER_LEVEL}`, CANVAS_WIDTH - 300, 30);
                updateCrosshairPosition();
            }

            // Update crosshair position smoothly
            function updateCrosshairPosition() {
                currentCrosshairX += (targetCrosshairX - currentCrosshairX) * smoothingFactor;
                currentCrosshairY += (targetCrosshairY - currentCrosshairY) * smoothingFactor;

                // Position crosshair relative to gameContainer, as canvas is fixed within it.
                crosshair.style.left = `${currentCrosshairX}px`;
                crosshair.style.top = `${currentCrosshairY}px`;
            }

            // Draw begin level screen (for transitions between levels, not initial start)
            function drawBeginLevel() {
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(100, 150, 600, 300);
                
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('DEFEND YOUR CITIES', CANVAS_WIDTH / 2, 200);
                
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`LEVEL ${level}`, CANVAS_WIDTH / 2, 250);
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('CLICK TO START', CANVAS_WIDTH / 2, 350);
                
                ctx.textAlign = 'left';
            }

            // Draw score
            function drawScore() {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${score}`, 20, 30);
            }

            // Draw level
            function drawLevel() {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Level: ${level}`, CANVAS_WIDTH - 150, 30);
            }

            // Draw end level screen
            function drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus) {
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(100, 100, 600, 400);
                
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL COMPLETE!', CANVAS_WIDTH / 2, 150);
                
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Missiles Left: ${missilesLeft}`, CANVAS_WIDTH / 2, 200);
                ctx.fillText(`Bonus: ${missilesBonus}`, CANVAS_WIDTH / 2, 240);
                
                ctx.fillText(`Cities Saved: ${citiesSaved}`, CANVAS_WIDTH / 2, 300);
                ctx.fillText(`Bonus: ${citiesBonus}`, CANVAS_WIDTH / 2, 340);
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('Preparing next level...', CANVAS_WIDTH / 2, 400);
                
                ctx.textAlign = 'left';
            }

            // Draw end game screen
            function drawEndGame() {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                
                ctx.font = 'bold 30px Arial';
                ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('CLICK TO PLAY AGAIN', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80);
                
                ctx.textAlign = 'left';
            }

            // Draw cities
            function drawCities() {
                cities.forEach(city => {
                    if(city.active) {
                        city.draw();
                    }
                });
            }

            // Draw anti-missile batteries
            function drawAntiMissileBatteries() {
                antiMissileBatteries.forEach(amb => {
                    amb.draw();
                });
            }

            // Get score multiplier based on level
            function getMultiplier() {
                return Math.min(6, Math.floor((level + 1) / 2));
            }

            // Draw background with stars and ground
            function drawBackground() {
                // Black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw stars
                ctx.fillStyle = '#fff';
                for(let i = 0; i < 100; i++) {
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = Math.random() * (CANVAS_HEIGHT - GROUND_HEIGHT);
                    const size = Math.random() * 1.5;
                    ctx.fillRect(x, y, size, size);
                }
                
                // Draw ground
                const groundY = CANVAS_HEIGHT - GROUND_HEIGHT;
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);
                ctx.lineTo(0, groundY);
                
                let x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 20 + Math.random() * 30;
                    const heightVariation = Math.random() * 15;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                
                ctx.lineTo(CANVAS_WIDTH, groundY);
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();
                
                // Draw ground details
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.beginPath();
                x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 50 + Math.random() * 50;
                    const heightVariation = Math.random() * 10;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                ctx.stroke();
            }

            // City class with improved graphics
            class City {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.active = true;
                    this.width = 60;
                    this.height = 40;
                }

                draw() {
                    if(!this.active) return;
                    
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;

                    ctx.fillStyle = '#222';
                    ctx.fillRect(baseX - 5, baseY - 10, this.width + 10, 10);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(baseX - 2, baseY - 12, this.width + 4, 2); 

                    const buildingTypes = [
                        { widthFactor: 0.2, heightFactor: 1.2, color: 'hsl(200, 80%, 50%)' },
                        { widthFactor: 0.25, heightFactor: 1.5, color: 'hsl(280, 80%, 60%)' },
                        { widthFactor: 0.22, heightFactor: 1.0, color: 'hsl(160, 70%, 55%)' }
                    ];
                    
                    let currentX = baseX + 5;

                    for (let i = 0; i < buildingTypes.length; i++) {
                        const type = buildingTypes[i];
                        const buildingWidth = this.width * type.widthFactor;
                        const buildingHeight = this.height * type.heightFactor;
                        const buildingColor = type.color;

                        ctx.fillStyle = buildingColor;
                        ctx.beginPath();
                        ctx.moveTo(currentX, baseY - 10);
                        ctx.lineTo(currentX, baseY - 10 - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - 10 - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - 10);
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = `rgba(0, 255, 255, 0.8)`;
                        ctx.fillRect(currentX + buildingWidth * 0.1, baseY - 10 - buildingHeight - 3, buildingWidth * 0.8, 3);
                        
                        ctx.fillStyle = '#0ff';
                        const panelHeight = 5;
                        const panelWidth = buildingWidth * 0.6;
                        for (let r = 0; r < Math.floor(buildingHeight / (panelHeight + 8)); r++) {
                            ctx.fillRect(currentX + (buildingWidth - panelWidth) / 2, 
                                         baseY - 10 - buildingHeight + 5 + r * (panelHeight + 8),
                                         panelWidth, panelHeight);
                        }
                        
                        currentX += buildingWidth + 5;
                    }

                    const domeRadius = this.width / 2;
                    const domeCenterX = this.x;
                    const domeCenterY = baseY - this.height * 1.3;

                    const gradient = ctx.createRadialGradient(
                        domeCenterX, domeCenterY - domeRadius / 3, 0,
                        domeCenterX, domeCenterY, domeRadius
                    );
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.7)');
                    gradient.addColorStop(0.8, 'rgba(0, 100, 255, 0.5)');
                    gradient.addColorStop(1, 'rgba(0, 50, 150, 0.3)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(domeCenterX, domeCenterY, domeRadius, Math.PI, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.arc(domeCenterX - domeRadius * 0.8, domeCenterY, 2, 0, Math.PI * 2);
                    ctx.arc(domeCenterX + domeRadius * 0.8, domeCenterY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Anti-missile battery class
            class AntiMissileBattery {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.missilesLeft = 10;
                    this.width = 40;
                    this.height = 30;
                    this.active = true; // Added property to know if it's active
                    this.health = 3;    // Added property for health (3 hits to destroy)
                }

                hasMissile() {
                    return this.missilesLeft > 0 && this.active; // Can only fire if active
                }

                draw() {
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;

                    if (!this.active) {
                        // Draw destruction state (rubble)
                        ctx.fillStyle = '#333'; // Dark gray rubble
                        ctx.fillRect(baseX + 5, baseY - 5, this.width - 10, 10); // Rubble base
                        ctx.fillRect(baseX + 10, baseY - 15, this.width - 20, 10); // Rubble top
                        ctx.fillStyle = '#111'; // Deeper shadows
                        ctx.fillRect(baseX + 15, baseY - 8, 10, 5);
                        return; // Do not draw active parts if destroyed
                    }
                    
                    // Original drawing code for active battery
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(baseX, baseY - 5, this.width, 5);

                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(baseX + 5, baseY - 5);
                    ctx.lineTo(baseX + 10, baseY - this.height);
                    ctx.lineTo(baseX + this.width - 10, baseY - this.height);
                    ctx.lineTo(baseX + this.width - 5, baseY - 5);
                    ctx.closePath();
                    ctx.fill();

                    const launcherColor = '#666';
                    const launcherWidth = 5;
                    const launcherHeight = 20;

                    ctx.fillStyle = launcherColor;
                    ctx.fillRect(this.x - 15, baseY - launcherHeight - 10, launcherWidth, launcherHeight);
                    ctx.fillRect(this.x - 15 + launcherWidth, baseY - launcherHeight - 10, launcherWidth / 2, launcherHeight / 2);

                    ctx.fillStyle = launcherColor;
                    ctx.fillRect(this.x + 10, baseY - launcherHeight - 10, launcherWidth, launcherHeight);
                    ctx.fillRect(this.x + 10 - launcherWidth / 2, baseY - launcherHeight - 10, launcherWidth / 2, launcherHeight / 2);

                    const missileSiloColor = '#222';
                    const missileColor = '#ADD8E6';

                    ctx.fillStyle = missileSiloColor;
                    ctx.fillRect(this.x - 7, baseY - 15, 14, 15);

                    const maxSilos = 6;
                    const siloSpacing = 7;
                    const siloBaseY = baseY - 5;
                    const missileHeightSmall = 8;
                    const missileWidthSmall = 2;

                    for (let i = 0; i < Math.min(this.missilesLeft, maxSilos); i++) {
                        const siloX = baseX + (i * siloSpacing) + 5;

                        ctx.fillStyle = missileSiloColor;
                        ctx.fillRect(siloX, siloBaseY - missileHeightSmall - 2, missileWidthSmall + 2, missileHeightSmall + 2);

                        ctx.fillStyle = missileColor;
                        ctx.fillRect(siloX + 1, siloBaseY - missileHeightSmall - 1, missileWidthSmall, missileHeightSmall);
                    }
                    
                    if(this.missilesLeft > maxSilos) {
                        ctx.fillStyle = '#0f0';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(`+${this.missilesLeft - maxSilos}`, this.x + 15, this.y - 15);
                    }

                    // Draw health indicator if damaged
                    if (this.health < 3 && this.active) {
                        ctx.fillStyle = (this.health === 1) ? 'red' : 'orange'; // Red for 1 life, Orange for 2 lives
                        const barWidth = (this.health / 3) * this.width * 0.8;
                        ctx.fillRect(baseX + this.width * 0.1, baseY - this.height - 5, barWidth, 3);
                        ctx.strokeStyle = 'black';
                        ctx.strokeRect(baseX + this.width * 0.1, baseY - this.height - 5, this.width * 0.8, 3);
                    }
                }
            }

            // Base Missile class
            class Missile {
                constructor(options) {
                    this.startX = options.startX;
                    this.startY = options.startY;
                    this.endX = options.endX;
                    this.endY = options.endY;
                    this.color = options.color;
                    this.trailColor = options.trailColor;
                    this.x = options.startX;
                    this.y = options.startY;
                    this.state = MISSILE.active;
                    this.width = 3;
                    this.height = 3;
                    this.explodeRadius = 0;
                    this.speedFactor = options.speedFactor || 1;
                }

                draw() {
                    if(this.state === MISSILE.active) {
                        const gradient = ctx.createLinearGradient(this.startX, this.startY, this.x, this.y);
                        gradient.addColorStop(0, this.trailColor);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(this.startX, this.startY);
                        ctx.lineTo(this.x, this.y);
                        ctx.stroke();

                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if(this.color === '#0f0') {
                            ctx.shadowColor = this.color;
                            ctx.shadowBlur = 10;
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    } else if(this.state === MISSILE.exploding || this.state === MISSILE.imploding) {
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.explodeRadius
                        );
                        
                        if(this.state === MISSILE.exploding) {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            gradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.6)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        }
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        explodeOtherMissiles(this, ctx);
                    }
                }

                explode() {
                    if(this.state === MISSILE.exploding) {
                        this.explodeRadius += 2 * this.speedFactor;
                    }
                    if(this.explodeRadius > 40) {
                        this.state = MISSILE.imploding;
                    }
                    if(this.state === MISSILE.imploding) {
                        this.explodeRadius -= 3 * this.speedFactor;
                        if(this.groundExplosion) {
                            if(this.target && this.target[2] instanceof City) {
                                this.target[2].active = false;
                                // NEW: Check if all cities have been destroyed immediately
                                checkAllCitiesDestroyed(); 
                            } else if (this.target && this.target[2] instanceof AntiMissileBattery) { // Target is an AntiMissileBattery
                                const targetBattery = this.target[2];
                                if (targetBattery.active) { // Only damage if battery is active
                                    targetBattery.health--;
                                    if (targetBattery.health <= 0) {
                                        targetBattery.active = false; // Deactivate if health runs out
                                        targetBattery.missilesLeft = 0; // No more missiles if destroyed
                                        playSound('batteryDestroyed'); // Optional sound for destroyed battery
                                        console.log('Battery destroyed!');
                                    } else {
                                        // playSound('hit'); // Optional sound for hit but not destroyed
                                        console.log(`Battery hit! Health remaining: ${targetBattery.health}`);
                                    }
                                }
                            }
                        }
                    }
                    if(this.explodeRadius < 0) {
                        this.state = MISSILE.exploded;
                    }
                }
            }

            // Player's Missile class
            class PlayerMissile extends Missile {
                constructor(source, endX, endY) {
                    const amb = antiMissileBatteries[source];
                    const speedFactor = (source === 1) ? 1.5 : 1;
                    
                    super({
                        startX: amb.x,
                        startY: amb.y,
                        endX: endX,
                        endY: endY,
                        color: '#0f0',
                        trailColor: 'rgba(0, 255, 255, 0.7)',
                        speedFactor: speedFactor
                    });

                    const xDistance = this.endX - this.startX;
                    const yDistance = this.endY - this.startY;
                    
                    const distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
                    const distancePerFrame = 15 * this.speedFactor;
                    const scale = distance / distancePerFrame;

                    this.dx = xDistance / scale;
                    this.dy = yDistance / scale;
                    amb.missilesLeft--;
                }

                update() {
                    if(this.state === MISSILE.active && this.y <= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                    } else {
                        this.explode();
                    }
                }
            }

            // Player shoot function
            function playerShoot(x, y) {
                // Adjust coordinates to be relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;

                if(canvasY >= 50 && canvasY <= CANVAS_HEIGHT - GROUND_HEIGHT - 50) {
                    const source = whichAntiMissileBattery(canvasX);
                    if(source === -1) return;
                    
                    playerMissiles.push(new PlayerMissile(source, canvasX, canvasY));
                    
                    playSound('shoot');
                }
            }

            // Enemy's Missile class
            class EnemyMissile extends Missile {
                constructor(targets, isFast = false, waveSpeedFactor = 1, isFromPlane = false, planeX = 0, planeY = 0) {
                    let startX, startY;
                    if (isFromPlane) {
                        startX = planeX;
                        startY = planeY;
                    } else {
                        startX = rand(0, CANVAS_WIDTH);
                        startY = 0;
                    }
                    
                    const speedFactor = (isFast ? 1.5 : 1) * waveSpeedFactor;
                    const target = targets[rand(0, targets.length - 1)];
                    
                    super({
                        startX: startX,
                        startY: startY,
                        endX: target[0],
                        endY: target[1],
                        color: '#f00',
                        trailColor: 'rgba(255, 100, 100, 0.5)',
                        speedFactor: speedFactor
                    });

                    let baseSpeed = 800;
                    baseSpeed = Math.max(150, baseSpeed - (level * 50)); 
                    
                    const framesToTarget = (baseSpeed * (0.4 + Math.random() * 1.2)) / this.speedFactor; 

                    this.dx = (this.endX - this.startX) / framesToTarget;
                    this.dy = (this.endY - this.startY) / framesToTarget;
                    this.target = target;
                    
                    this.delay = isFromPlane ? 0 : rand(0, Math.max(10, 60 - level)); // No delay for plane missiles
                    this.groundExplosion = false;
                }

                update() {
                    if(this.delay) {
                        this.delay--;
                        return;
                    }
                    
                    if(this.state === MISSILE.active && this.y >= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                        this.groundExplosion = true;
                        
                        playSound('explosion');
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                        
                        if(Math.random() < 0.1) {
                            this.x += (Math.random() - 0.5) * 3;
                        }
                    } else {
                        this.explode();
                    }
                }
            }

            // Enemy Plane class
            class EnemyPlane {
                constructor() {
                    this.width = 70;
                    this.height = 25;
                    this.y = rand(50, CANVAS_HEIGHT / 3); // Random height in the upper third
                    this.speed = rand(2, 4) * (1 + level * 0.1); // Random speed, increases with level
                    this.direction = Math.random() < 0.5 ? 1 : -1; // 1 for right, -1 for left
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width; // Starts off-screen
                    this.active = true;
                    this.missileLaunchCooldown = 60; // Frames between missile launches
                    this.currentMissileCooldown = rand(10, this.missileLaunchCooldown);
                    this.missilesToLaunch = rand(1, 3); // Number of missiles to launch
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            // Draw plane explosion
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#666'; // Plane body
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 20)), this.y + 15 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 15)), this.y + 5 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 5)), this.y - 15 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Cockpit
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.arc(this.x - (this.direction * this.width * 0.1), this.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 2;
                            if (this.explodeRadius > 80) {
                                this.exploded = false; // End explosion animation
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Launch missiles
                    if (this.missilesToLaunch > 0) {
                        this.currentMissileCooldown--;
                        if (this.currentMissileCooldown <= 0) {
                            const targets = viableTargets();
                            if (targets.length > 0) {
                                enemyMissiles.push(new EnemyMissile(targets, true, 1.2, true, this.x, this.y));
                                this.missilesToLaunch--;
                                playSound('shoot');
                            }
                            this.currentMissileCooldown = rand(30, this.missileLaunchCooldown); // Reset cooldown
                        }
                    }

                    // Remove plane if it goes off-screen and has finished launching missiles
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    }
                }

                // Method for when the plane is hit
                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 500 * getMultiplier(); // Bonus for shooting down the plane (ya implementado)
                    planesShotDownThisLevel++; // NUEVO: Incrementar el contador de aviones derribados
                    checkPlaneReconstructionBonus(); // NUEVO: Verificar el bonus de reconstrucción
                    playSound('explosion');
                }
            }


            // Explode other missiles in radius
            function explodeOtherMissiles(missile, ctx) {
                if(!missile.groundExplosion) {
                    enemyMissiles.forEach(otherMissile => {
                        const distance = Math.sqrt(
                            Math.pow(missile.x - otherMissile.x, 2) +
                            Math.pow(missile.y - otherMissile.y, 2)
                        );
                        if(distance < missile.explodeRadius && otherMissile.state === MISSILE.active) {
                            score += 25 * getMultiplier();
                            otherMissile.state = MISSILE.exploding;
                        }
                    });

                    // Check if the player missile's explosion hits the enemy plane
                    if (enemyPlane && enemyPlane.active) {
                        const distanceToPlane = Math.sqrt(
                            Math.pow(missile.x - enemyPlane.x, 2) +
                            Math.pow(missile.y - enemyPlane.y, 2)
                        );
                        // Slightly increase the detection radius for the plane to make it easier to hit
                        if (distanceToPlane < missile.explodeRadius + 20) { 
                            enemyPlane.hit();
                            enemyPlane = null; // Remove the plane once hit
                        }
                    }
                }
            }

            // NUEVO: Función para verificar el bonus de reconstrucción de avión
            function checkPlaneReconstructionBonus() {
                if (planesShotDownThisLevel >= 3) {
                    reconstructRandomDestroyedStructure();
                    planesShotDownThisLevel = 0; // Reiniciar el contador después del bonus
                }
            }

            // NUEVO: Función para reconstruir una estructura aleatoria destruida
            function reconstructRandomDestroyedStructure() {
                const destroyedCities = cities.filter(city => !city.active);
                const destroyedBatteries = antiMissileBatteries.filter(battery => !battery.active);

                const allDestroyed = [...destroyedCities, ...destroyedBatteries];

                if (allDestroyed.length > 0) {
                    const structureToRebuild = allDestroyed[rand(0, allDestroyed.length - 1)];
                    if (structureToRebuild instanceof City) {
                        structureToRebuild.active = true;
                        console.log("¡Ciudad reconstruida por derribar 3 aviones!");
                    } else if (structureToRebuild instanceof AntiMissileBattery) {
                        structureToRebuild.active = true;
                        structureToRebuild.health = 3; // Restaurar salud completa
                        structureToRebuild.missilesLeft = 10; // Recargar misiles
                        console.log("¡Lanzadera reconstruida por derribar 3 aviones!");
                    }
                }
            }


            // Get viable targets for enemy missiles
            function viableTargets() {
                const targets = [];

                cities.forEach(city => {
                    if(city.active) {
                        targets.push([city.x, city.y - city.height + 10, city]);
                    }
                });

                // Add logic for planes to aim at a smaller number of targets if needed
                // For now, we use the same logic as normal missiles.

                while(targets.length > 3) {
                    targets.splice(rand(0, targets.length - 1), 1);
                }

                if(Math.random() < (level * 0.05)) { 
                    antiMissileBatteries.forEach(amb => {
                        // Only attack active batteries
                        if (amb.active) { 
                            targets.push([amb.x, amb.y - amb.height, amb]);
                        }
                    });
                }
                
                return targets;
            }

            // Game loop
            function nextFrame() {
                drawGameState();
                updateEnemyMissiles();
                drawEnemyMissiles();
                updatePlayerMissiles();
                drawPlayerMissiles();

                // Update and draw the plane if active
                if (enemyPlane && enemyPlane.active) {
                    enemyPlane.update();
                    enemyPlane.draw();
                } else if (enemyPlane && enemyPlane.exploded) { // Draw plane explosion
                    enemyPlane.update();
                    enemyPlane.draw();
                }
                
                if (waveActive && enemyMissiles.length === 0 && (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded)) {
                    waveActive = false;
                    stopLevel();
                    setTimeout(() => {
                        if (currentWave < WAVES_PER_LEVEL) { 
                            startNextWave();
                        } else { 
                            checkEndLevel(); 
                        }
                    }, 3000);
                }
            }

            // Spawns an enemy plane
            function spawnEnemyPlane() {
                // Possibility for a plane to appear, only if no active one and we haven't reached the limit per level
                if (!enemyPlane && planesPerLevel < MAX_PLANES_PER_LEVEL) {
                    if (Math.random() < 0.3 + (level * 0.05)) { // 30% probability + 5% per level
                        setTimeout(() => {
                            enemyPlane = new EnemyPlane();
                            planesPerLevel++;
                            console.log(`Enemy plane appearing. Planes this level: ${planesPerLevel}`);
                        }, rand(2000, 5000)); // Appears after 2-5 seconds
                    }
                }
            }

            // Check for end of level
            function checkEndLevel() {
                // Consider the plane as well for wave/level end
                if(enemyMissiles.length === 0 && (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded) && gameStarted && currentWave >= WAVES_PER_LEVEL) {
                    stopLevel();
                    gameContainer.removeEventListener('click', handleShoot);
                    gameContainer.removeEventListener('mousemove', handleMouseMove);
                    crosshair.style.display = 'none';
                    
                    const missilesLeft = totalMissilesLeft();
                    const citiesSaved = totalCitiesSaved();

                    // The game over condition by cities is moved to checkAllCitiesDestroyed
                    if(citiesSaved === 0) {
                        endGame(missilesLeft); // This should be unreachable if checkAllCitiesDestroyed works
                    } else {
                        endLevel(missilesLeft, citiesSaved);
                    }
                }
            }

            // NEW: Function to check if all cities have been destroyed
            function checkAllCitiesDestroyed() {
                if (totalCitiesSaved() === 0) {
                    stopLevel(); // Stop the game loop
                    gameContainer.removeEventListener('click', handleShoot); // Deactivate shooting
                    gameContainer.removeEventListener('mousemove', handleMouseMove); // Deactivate crosshair movement
                    crosshair.style.display = 'none'; // Hide crosshair
                    endGame(totalMissilesLeft()); // End the game
                }
            }


            // Handle end of level
            function endLevel(missilesLeft, citiesSaved) {
                const missilesBonus = missilesLeft * 5 * getMultiplier();
                const citiesBonus = citiesSaved * 100 * getMultiplier();

                drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus);

                setTimeout(() => {
                    score += missilesBonus + citiesBonus;
                    drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus);
                }, 2000);

                setTimeout(setupNextLevel, 4000);
            }

            // Setup next level
            function setupNextLevel() {
                const previousScore = score; // Save score before adding end-of-level bonuses
                level++; 
                planesPerLevel = 0; // Reset plane counter for the new level
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados en el nuevo nivel

                // LEVEL 1 TO 2 REWARD LOGIC (previous)
                // Maintained, but rebuilding is now handled by the new general score logic.
                if (level === 2 && totalCitiesSaved() === 6) { // If all cities were saved in level 1
                    bonusMissilesForNextWave = 10; 
                    console.log("10 extra missiles per battery for Level 2 for saving all cities!"); 
                }

                // NEW LOGIC: Rebuild a city if level score was > 3000
                if (previousScore >= 3000) { // Evaluates the score from the PREVIOUS level
                    const destroyedCities = cities.filter(city => !city.active);
                    if (destroyedCities.length > 0) {
                        const cityToRebuild = destroyedCities[rand(0, destroyedCities.length - 1)];
                        cityToRebuild.active = true;
                        console.log("City rebuilt due to high score!"); 
                    }
                }


                // Rebuild and repair all batteries for the new level
                antiMissileBatteries.forEach(amb => {
                    amb.active = true; // Activate battery
                    amb.health = 3;    // Restore full health
                });
                console.log("Launchers rebuilt and repaired!"); 

                initializeLevel(); 
                gameContainer.addEventListener('click', handleShoot);
                gameContainer.addEventListener('mousemove', handleMouseMove);
                crosshair.style.display = 'block';
            }

            // Handle end of game
            function endGame(missilesLeft) {
                score += missilesLeft * 5 * getMultiplier();
                drawEndGame();
                
                playSound('gameOver');

                const resetGame = () => {
                    document.removeEventListener('click', resetGame);
                    location.reload(); 
                };
                
                document.addEventListener('click', resetGame);
            }

            // Get total missiles left
            function totalMissilesLeft() {
                // Only count missiles from active batteries
                return antiMissileBatteries.filter(amb => amb.active).reduce((total, amb) => total + amb.missilesLeft, 0);
            }

            // Get total cities saved
            function totalCitiesSaved() {
                return cities.filter(city => city.active).length;
            }

            // Update enemy missiles
            function updateEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.update());
                enemyMissiles = enemyMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw enemy missiles
            function drawEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.draw());
            }

            // Update player missiles
            function updatePlayerMissiles() {
                playerMissiles.forEach(missile => missile.update());
                playerMissiles = playerMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw player missiles
            function drawPlayerMissiles() {
                playerMissiles.forEach(missile => missile.draw());
            }

            // Stop level animation
            function stopLevel() {
                cancelAnimationFrame(timerID);
            }

            // Start level animation
            function startLevel() {
                gameStarted = true;
                const animate = () => {
                    nextFrame();
                    timerID = requestAnimationFrame(animate);
                };
                animate();
            }

            // Determine which anti-missile battery to use
            function whichAntiMissileBattery(x) {
                // Modified to prioritize active batteries
                const getUsableBattery = (indices) => {
                    for (const index of indices) {
                        if (antiMissileBatteries[index].hasMissile()) {
                            return index;
                        }
                    }
                    return -1; // No usable battery found
                };

                // Check if any battery is active and has missiles
                if(!antiMissileBatteries.some(amb => amb.hasMissile())) {
                    return -1;
                }

                if(x <= CANVAS_WIDTH / 3) {
                    return getUsableBattery([0, 1, 2]);
                } else if(x <= (2 * CANVAS_WIDTH / 3)) {
                    if(antiMissileBatteries[1].hasMissile()) return 1;
                    return (x <= CANVAS_WIDTH / 2) ? getUsableBattery([0, 2]) : getUsableBattery([2, 0]);
                } else {
                    return getUsableBattery([2, 1, 0]);
                }
            }

            // Handle mouse move to update target crosshair position
            function handleMouseMove(event) {
                const rect = canvas.getBoundingClientRect();
                targetCrosshairX = event.clientX - rect.left;
                targetCrosshairY = event.clientY - rect.top;
            }

            // Handle shoot event 
            function handleShoot(event) {
                playerShoot(event.clientX, event.clientY);
            }

            // Toggle sound function for key press (button removed)
            function toggleSound() {
                soundEnabled = !soundEnabled;
                const soundStatus = soundEnabled ? 'ON' : 'OFF';
                console.log(`Sound: ${soundStatus}`);
                // You might want to update the splash screen text here if it's visible,
                // or provide some other visual feedback to the user.
            }

            // Handle key press for sound toggle
            function handleKeyPress(event) {
                if (event.key === 's' || event.key === 'S') {
                    toggleSound();
                }
            }

            // Simple sound effects (add sounds if you have the base64 data for 'batteryDestroyed' and 'hit')
            function playSound(type) {
                if(!soundEnabled || typeof Audio === 'undefined') return;
                
                try {
                    let sound;
                    switch(type) {
                        case 'shoot':
                            // Data for a short, sharp shooting sound
                            sound = new Audio('data:audio/wav;base64,UklGRqgoAQBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQiwJgAAihoAAIgeAACFIgAAqCQAAKcnAACoJwAAeicAAIIfAACAIQAAmSEAAKMkAACOIwAAnCMAAJ4lAACKJQAAgiMAAIwjAACNIwAAhSMAAKclAACFJwAAkiQAAKIkAACWIgAAgyMAAIUfAACeHQAAjysAALMwAAC1LAAAsSwAAKctAACoJwAAnyIAAI4gAACuKQAAtisAALArAACzKQAAnCUAAJwiAACYIwAAkSUAAJwgAACjHgAAjyYAAIclAACJHQAAjyMAACdBAABcRAAA9w4AAD07AAC3LgAAty0AALMtAACvKwAAsCsAALEyAACiNwAAkDAAAIA4AAD1MwAA8S4AALMxAACrMAAAtzQAAK8xAACpLAQArjAAAKkwAAKg7AAC+LQAA7i4AADU+AACyNQAAtzQAAKA8AAD5LwAA7icAAFUQAACkIQAAmBoAAKgnAACYIgAAmSMAAJomAAClJQAAmiYAAKgoAACoKAACYIQAAnCQAAKkgAACgIQAAkSgAAL8wAACiKQAAmyQAAKUjAACaJQAAkSQAAJojAACaIAAAjiEAAJIgAACcIQAAoB8AAJoiAACYIwAAmiIAAJogAACKHwAAkCEAAIwfAACaJAAAmCMAAJYhAACaIAAAjycAALc5AAC+NwAAqS8AAKwvAAC3JwAAjyUAALQnAAC4JgAAqioAALIrAACxKgAAmyQAAJ4nAACgKAAApSUAAJwiAACYJAAAngAAAJYjAACZIgAAnSEAAJMfAACWIAAAkB0AAJceAACZJQAAhCMAAH4dAABzIwAA4yoAADkuAACwLAAAsS0AALAtAACkKwAAqiwAAKgsAACzKgAAuywAAKEsAACaMAAAmS4AAK0vAACfMgAAqjQAAKk1AACdOwAA4i4AALkuAAC8LQAAtC4AAK0tAACjKwAAtS4AAJ0sAACeJwAAqSUAALQpAAC2JwAAwSkAAKEqAACxKwAAuCwAAKQvAACmMAAAoTEAAJA6AAA4OAAAtCkAAJ4uAACeLgAAoDAAAKw2AACeNQAAnDUAAKE0AACuMgAApzMAAKQ4AACQNgAAiTgAAF89AADvNwAAtigAAKEqAAC+LwAAqy8AAKMvAACnMQAAnjIAAKM0AACkNAAApDcAAKI4AACcOAAAnDUAAKE6AAA5PAAAsCkAAKMqAACoKwAAqiwAALQtAACyKwAAuywAAKovAACnKwAAqiwAAK0tAAC0LgAAty8AAKwxAAC0MgAAuDAAALEyAAC7MQAApDcAAKc1AACkNgAAtzgAALk6AACkNAAAqTQAALg0AAC2NwAAuDcAAKM5AAA2RAAA3DgAALMsAACnLgAAsi8AALcyAACqNAAApzIAALM0AACiNgAAgTMAAIo0AADYNAAArDQAAJgyAACbPgAA3DMAALKWAwAFBwYBAAAAAAAAAAAAAAAA');
                            break;
                        case 'explosion':
                            // Data for an explosion sound
                            sound = new Audio('data:audio/wav;base64,UklGRtIoAQBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQjUKgAARCsAAEEiAACJIgAAgysAAJQuAACxPgAAs1QAAIE+AACYJgAA1i8AAD5PAACaOgAA3D8AANwxAAC3QAAA4D8AAPFCAAB9YQAADlQAAC9bAAC5gAAA6AAAAKjTAAAA6gAAAJXgAACj7gAAj8QAAPUoAABfOQAAQjYAAFE3AABdRAAA+icAAKMsAACdMQAA8DEAAFk9AACeKgAAjy8AAN45AADTNAAAozsAADs+AAC/PQAAnTsAAOQ3AACXNwAAjDUAAIk4AAA/NQAARzQAAKM3AAB/NgAARzsAAKA4AABwOQAA9DoAADs7AADTPAAAmzsAAMk4AACbMgAAmDMAACo3AACfMgAAqjkAAKgsAACrLAAAsisAAK0sAACzLgAAuS8AAKMxAACuMgAAuzIAAIE4AAC4NQAApzYAAKQ2AACgMAAAuSgAAKMtAAC2KwAAsSsAALQrAACrKgAAuS0AAKwsAACeKQAAoy8AAJ8wAACzMwAApzIAALk3AACoOgAAoywAAIA3AACuMQAAqikAAKcqAACbKAAAuigAAJ8nAACZKQAAjygAAJAoAACmKQAAmSkAAJsoAACmKAAAniQAAJ8lAACKJgAAkCEAAIAjAACAJQAAnCYAAKMnAACbKAAAmCcAAJgmAACZJAAAkCMASlZgGkXQ+0Jv/f3d6v/Wv/7U//4m/82//iT/6Q//yR/7q//1b//hU//n0P/r+/3q+P///wAAAA==');
                            break;
                        case 'gameOver':
                            // Data for a game over sound (usually a low, sustained tone or a series of tones)
                            sound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...');
                            break;
                        case 'batteryDestroyed': // Opcional: Sonido para cuando una batería es destruida
                            // sound = new Audio('data:audio/wav;base64,...'); 
                            console.log('Battery Destroyed Sound Placeholder');
                            break;
                        case 'hit': // Opcional: Sonido para cuando una batería es golpeada pero no destruida
                            // sound = new Audio('data:audio/wav;base64,...');
                            console.log('Battery Hit Sound Placeholder');
                            break;
                    }
                    
                    if(sound) {
                        sound.volume = 0.3;
                        sound.play().catch(e => console.log('Sound playback failed:', e));
                    }
                } catch(e) {
                    console.log('Sound error:', e);
                }
            }

            return {
                initialize,
                setupListeners
            };
        })();

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            missileCommand.initialize();
            missileCommand.setupListeners();
        });
    </script>
</body>
</html>
