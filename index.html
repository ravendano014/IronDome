<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Iron Dome Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #111;
            display: flex;
            flex-direction: column; /* Alinea el título y el juego en columna */
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            cursor: none; /* Ocultar el cursor del sistema para usar nuestro crosshair */
        }

        .game-container {
            position: relative;
            background-color: #000;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            width: 800px; /* Vuelve al ancho fijo */
            height: 600px; /* Vuelve al alto fijo */
        }

        canvas {
            display: block; /* Asegura que no haya espacio extra debajo del canvas */
        }

        .crosshair {
            position: absolute;
            width: 30px; /* Vuelve al tamaño fijo del crosshair */
            height: 30px; /* Vuelve al tamaño fijo del crosshair */
            border: 2px solid lime;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            display: none; /* Inicialmente oculto */
        }

        h1 {
            color: #0ff;
            text-align: center;
            font-family: 'Arial', sans-serif;
            font-size: 36px;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 10px;
        }

        /* Estilos para la pantalla de inicio */
        #splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Fondo oscuro semitransparente */
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1001; /* Asegura que esté por encima del juego */
            font-family: 'Arial', sans-serif;
            cursor: pointer; /* Indica que es clickeable */
        }

        #splash-screen h2 {
            color: #0ff;
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #0ff;
        }

        #splash-screen p {
            font-size: 1.5em;
            margin: 5px 0;
            color: #eee;
            max-width: 70%; /* Limita el ancho del texto */
        }

        #splash-screen .click-to-start {
            margin-top: 40px;
            font-size: 2em;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            animation: pulse 1.5s infinite alternate; /* Animación de pulsación */
        }

        @keyframes pulse {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div>
        <h1>Iron Dome Enhanced</h1>
        <div class="game-container">
            <canvas width="800" height="600"></canvas>
            <div class="crosshair"></div>
            
            <div id="splash-screen">
                <h2>Iron Dome Enhanced</h2>
                <p>Defend your cities from the enemy missile rain!</p>
                <p>Move the mouse to aim and click to launch a defensive missile.</p>
                <p>Each battery has limited missiles, use them strategically!</p>
                <p>Press 'S' to toggle sound ON/OFF.</p>
                <p class="click-to-start">Click anywhere to start</p>
            </div>
        </div>
    </div>

    <script>
        // Iron Dome Enhanced
        const missileCommand = (function() {
            const canvas = document.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            const gameContainer = document.querySelector('.game-container');
            const crosshair = document.querySelector('.crosshair');
            const splashScreen = document.getElementById('splash-screen');

            // Constants
            const CANVAS_WIDTH = 800;
            const CANVAS_HEIGHT = 600;
            const GROUND_HEIGHT = 100; // Fixed ground height
            const MAX_STEALTH_PLANES_PER_LEVEL = 10; // Five stelth plane per level
            const MAX_CARGO_PLANES_PER_LEVEL = 10; // Four cargo plane per level
            const WAVES_PER_LEVEL = 10; // Each level will have 10 waves

            const MISSILE = {
                active: 1,
                exploding: 2,
                imploding: 3,
                exploded: 4
            };

            // Variables
            let score = 0;
            let level = 1;
            let cities = [];
            let antiMissileBatteries = [];
            let playerMissiles = [];
            let enemyMissiles = [];
            let timerID;
            let gameStarted = false;
            let soundEnabled = false; // Inicialmente deshabilitado

            let currentWave = 0;
            let waveActive = false;

            let targetCrosshairX = 0;
            let targetCrosshairY = 0;
            let currentCrosshairX = 0;
            let currentCrosshairY = 0;
            const smoothingFactor = 0.15;
            
            let bonusMissilesForNextWave = 0;
            let planesShotDownThisLevel = 0; // NUEVO: Contador de aviones derribados en el nivel actual
            let reconstructedCount = 0; // NUEVO: Contador de ciudades/lanzaderas reconstruidas
            let extraMissilesFromSpyPlane = 0; // Track missiles from spy plane

            // Enemy Plane
            let enemyPlane = null;
            let planesPerLevel = 0; // Counter for planes that have appeared in the current level
            const MAX_PLANES_PER_LEVEL = 10; // Maximum planes per level

            // Spy Plane (NEW)
            let spyPlane = null;
            let spyPlanesAppearedThisLevel = 0; // Counter for spy planes appeared in the current level
            const MAX_SPY_PLANES_PER_LEVEL = 10; // Maximum spy planes per level
            let spyPlaneWaveMissileBonus = 0; // Accumulates missile bonus from spy planes

            // Stealth Plane (NEW)
            let stealthPlane = null;
            let stealthPlanesAppearedThisLevel = 0;
            let stealthPlaneExplosionBonus = 1; // Multiplier for explosion radius (1 for normal, 2 for bonus)
            let stealthPlaneSpawnedThisLevel = false; // Track if stealth plane has spawned this level

            // Cargo Plane (NEW)
            let cargoPlane = null;
            let cargoPlanesAppearedThisLevel = 0;
            let cargoPlaneEnemyMissileReduction = 0; // Reduction in enemy missiles per wave (up to 2 per level)
            let cargoPlaneSpawnedThisLevel = false; // Track if cargo plane has spawned this level

            // Killer Plane (NEW)
            let killerPlane = null;
            let killerPlanesAppearedThisLevel = 0;
            const MAX_KILLER_PLANES_PER_LEVEL = 10; // Max one killer plane per level
            let citiesImmune = false; // Flag for city immunity
            let killerPlaneSpawnedThisLevel = false; // Track if killer plane has spawned this level

            // Initialize game
            function initialize() {
                // Set canvas dimensions explicitly (already set in HTML but good practice)
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;

                // Reset game state for a new game
                cities = [];
                antiMissileBatteries = [];
                playerMissiles = [];
                enemyMissiles = [];
                score = 0;
                level = 1;
                currentWave = 0;
                waveActive = false;
                gameStarted = false;
                soundEnabled = false;
                bonusMissilesForNextWave = 0; // Reset bonus at game start
                enemyPlane = null; // Reset plane
                planesPerLevel = 0; // Reset plane counter
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados
                reconstructedCount = 0; // Reiniciar contador de reconstrucciones
                spyPlane = null; // Reset spy plane
                spyPlanesAppearedThisLevel = 0; // Reset spy plane count
                spyPlaneWaveMissileBonus = 0; // Reset spy plane missile bonus
                extraMissilesFromSpyPlane = 0; // Reset bonus missiles from spy plane
                stealthPlane = null; // Reset stealth plane
                stealthPlanesAppearedThisLevel = 0; // Reset stealth plane count
                stealthPlaneExplosionBonus = 1; // Reset bonus
                stealthPlaneSpawnedThisLevel = false; // Reset flag for new game
                cargoPlane = null; // Reset cargo plane
                cargoPlanesAppearedThisLevel = 0; // Reset cargo plane count
                cargoPlaneEnemyMissileReduction = 0; // Reset bonus
                cargoPlaneSpawnedThisLevel = false; // Reset flag for new game
                killerPlane = null; // Reset killer plane
                killerPlanesAppearedThisLevel = 0; // Reset killer plane count
                citiesImmune = false; // Reset city immunity
                killerPlaneSpawnedThisLevel = false; // Reset flag for new game

                // Create cities
                cities.push(new City(100, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(200, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(300, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(500, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(600, CANVAS_HEIGHT - GROUND_HEIGHT + 20));
                cities.push(new City(700, CANVAS_HEIGHT - GROUND_HEIGHT + 20));

                // Create anti-missile batteries
                antiMissileBatteries.push(new AntiMissileBattery(50, CANVAS_HEIGHT - GROUND_HEIGHT));
                antiMissileBatteries.push(new AntiMissileBattery(400, CANVAS_HEIGHT - GROUND_HEIGHT));
                antiMissileBatteries.push(new AntiMissileBattery(750, CANVAS_HEIGHT - GROUND_HEIGHT));
                
                // Draw initial state (including splash screen)
                drawGameState(); 
                // Do NOT call initializeLevel or startLevel here. It will be called after splash screen click.
            }

            // Setup event listeners
            function setupListeners() {
                splashScreen.addEventListener('click', () => {
                    if (!gameStarted) {
                        splashScreen.style.display = 'none';
                        gameStarted = true;
                        initializeLevel();
                        gameContainer.addEventListener('click', handleShoot);
                        gameContainer.addEventListener('mousemove', handleMouseMove);
                        crosshair.style.display = 'block';
                    }
                });
                document.addEventListener('keydown', handleKeyPress);
            }

            // Initialize level
            function initializeLevel() {
                playerMissiles = [];
                enemyMissiles = [];
                currentWave = 0; 
                enemyPlane = null; // Ensure no active plane at level start
                planesPerLevel = 0; // Reset plane counter per level
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados por nivel
                reconstructedCount = 0; // Reiniciar contador de reconstrucciones por nivel
                spyPlane = null; // Reset spy plane for the new level
                spyPlanesAppearedThisLevel = 0; // Reset spy plane count for the new level
                spyPlaneWaveMissileBonus = 0; // Reset spy plane missile bonus for the new level
                extraMissilesFromSpyPlane = 0; // Reset bonus missiles from spy plane for the new level
                stealthPlane = null; // Reset stealth plane for the new level
                stealthPlanesAppearedThisLevel = 0; // Reset stealth plane count for the new level
                stealthPlaneExplosionBonus = 1; // Reset bonus for the new level
                stealthPlaneSpawnedThisLevel = false; // Reset flag for new level
                cargoPlane = null; // Reset cargo plane for the new level
                cargoPlanesAppearedThisLevel = 0; // Reset cargo plane count for the new level
                cargoPlaneEnemyMissileReduction = 0; // Reset bonus
                cargoPlaneSpawnedThisLevel = false; // Reset flag for new level
                killerPlane = null; // Reset killer plane
                killerPlanesAppearedThisLevel = 0; // Reset killer plane count
                citiesImmune = false; // Reset city immunity for the new level
                killerPlaneSpawnedThisLevel = false; // Reset flag for new level

                startNextWave(); 
            }

            // Start next wave
            function startNextWave() {
                currentWave++;
                if (currentWave > WAVES_PER_LEVEL) {
                    checkEndLevel(); 
                    return;
                }

                const initialMissiles = 10; // Starting missiles for each battery
                
                let missilesForThisWave = initialMissiles;
                if (level === 2 && currentWave === 1 && bonusMissilesForNextWave > 0) {
                    missilesForThisWave += bonusMissilesForNextWave;
                    bonusMissilesForNextWave = 0; 
                }

                const reductionPerTwoWaves = Math.floor((currentWave - 1) / 2);
                antiMissileBatteries.forEach(amb => {
                    // Only reload missiles if the battery is active
                    if (amb.active) { 
                        amb.missilesLeft = Math.max(0, missilesForThisWave - reductionPerTwoWaves + spyPlaneWaveMissileBonus); // Add spy plane bonus
                    } else {
                        amb.missilesLeft = 0; // Ensure no missiles if destroyed
                    }
                });

                waveActive = true;
                createEnemyMissiles();
                // Call spawnEnemyPlane after creating missiles, so it appears between waves
                spawnEnemyPlane(); 
                spawnSpyPlane(); // Attempt to spawn spy plane
                spawnStealthPlane(); // Attempt to spawn stealth plane (NEW)
                spawnCargoPlane(); // Attempt to spawn cargo plane (NEW)
                spawnKillerPlane(); // Attempt to spawn killer plane (NEW)

                drawGameState(); 
                startLevel(); 
            }

            // Create enemy missiles with increasing difficulty
            function createEnemyMissiles() {
                const targets = viableTargets();
                let numMissiles;
                let baseSpeedFactor;

                numMissiles = 5 + (level * 2) + Math.floor(currentWave * 0.5); 
                baseSpeedFactor = 1 - (level * 0.05) - (currentWave * 0.01); 
                baseSpeedFactor = Math.max(0.2, baseSpeedFactor); 

                if (level === 1) {
                     switch (currentWave) {
                        case 1: numMissiles = 5; baseSpeedFactor = 0.8; break;
                        case 2: numMissiles = 7; baseSpeedFactor = 0.75; break;
                        case 3: numMissiles = 9; baseSpeedFactor = 0.7; break;
                        case 4: numMissiles = 11; baseSpeedFactor = 0.65; break;
                        case 5: numMissiles = 13; baseSpeedFactor = 0.6; break;
                        case 6: numMissiles = 15; baseSpeedFactor = 0.55; break;
                        case 7: numMissiles = 17; baseSpeedFactor = 0.5; break;
                        case 8: numMissiles = 19; baseSpeedFactor = 0.45; break;
                        case 9: numMissiles = 21; baseSpeedFactor = 0.4; break;
                        case 10: numMissiles = 25; baseSpeedFactor = 0.35; break;
                    }
                }

                // Apply Cargo Plane missile reduction (NEW)
                numMissiles = Math.max(1, numMissiles - cargoPlaneEnemyMissileReduction);


                for(let i = 0; i < numMissiles; i++) {
                    const isFast = Math.random() < 0.3; 
                    enemyMissiles.push(new EnemyMissile(targets, isFast, baseSpeedFactor));
                }
            }

            // Random number helper
            function rand(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // Draw game state
            function drawGameState() {
                drawBackground();
                drawCities();
                drawAntiMissileBatteries();
                drawScore();
                drawLevel();
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Wave: ${currentWave}/${WAVES_PER_LEVEL}`, CANVAS_WIDTH - 300, 30);
                updateCrosshairPosition();
            }

            // Update crosshair position smoothly
            function updateCrosshairPosition() {
                currentCrosshairX += (targetCrosshairX - currentCrosshairX) * smoothingFactor;
                currentCrosshairY += (targetCrosshairY - currentCrosshairY) * smoothingFactor;

                // Position crosshair relative to gameContainer, as canvas is fixed within it.
                crosshair.style.left = `${currentCrosshairX}px`;
                crosshair.style.top = `${currentCrosshairY}px`;
            }

            // Draw begin level screen (for transitions between levels, not initial start)
            function drawBeginLevel() {
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(100, 150, 600, 300);
                
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('DEFEND YOUR CITIES', CANVAS_WIDTH / 2, 200);
                
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`LEVEL ${level}`, CANVAS_WIDTH / 2, 250);
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('CLICK TO START', CANVAS_WIDTH / 2, 350);
                
                ctx.textAlign = 'left';
            }

            // Draw score
            function drawScore() {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Score: ${score}`, 70, 30);
            }

            // Draw level
            function drawLevel() {
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`Level: ${level}`, CANVAS_WIDTH - 150, 30);
            }

            // Draw end level screen
            function drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthPlaneBonusActive, cargoPlaneMissileReduction, killerPlaneImmunityActive) { // Added killerPlaneImmunityActive
                drawGameState();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(100, 100, 600, 400);
                
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL COMPLETE!', CANVAS_WIDTH / 2, 150);
                
                ctx.font = 'bold 20px Arial'; // Adjusted font size for more lines
                ctx.fillText(`Missiles Left: ${missilesLeft} (Bonus: ${missilesBonus})`, CANVAS_WIDTH / 2, 180); // Adjusted Y
                ctx.fillText(`Cities Saved: ${citiesSaved} (Bonus: ${citiesBonus})`, CANVAS_WIDTH / 2, 210); // Adjusted Y
                
                // NEW: Display planes shot down and structures rebuilt
                ctx.fillText(`Planes Shot Down: ${planesShotDown}`, CANVAS_WIDTH / 2, 240); // Adjusted Y
                ctx.fillText(`Structures Rebuilt: ${reconstructedCount}`, CANVAS_WIDTH / 2, 270); // Adjusted Y (Use reconstructedCount directly)
                if (spyPlaneBonus > 0) { // Changed spyPlaneMissileBonus to spyPlaneBonus
                    ctx.fillText(`Spy Plane Bonuses: +${spyPlaneBonus} Misiles/Oleada!`, CANVAS_WIDTH / 2, 300); // Adjusted Y
                }
                if (stealthPlaneBonusActive) { // NEW: Display stealth plane bonus
                    ctx.fillText(`Stealth Plane Bonus: Double Explosion Radius!`, CANVAS_WIDTH / 2, 330); // Adjusted Y
                }
                if (cargoPlaneMissileReduction > 0) { // NEW: Display cargo plane bonus
                    ctx.fillText(`Cargo Plane Bonus: -${cargoPlaneEnemyMissileReduction} Enemy Missiles/Wave!`, CANVAS_WIDTH / 2, 360); // Adjusted Y
                }
                if (killerPlaneImmunityActive) { // NEW: Display killer plane bonus
                    ctx.fillText(`Killer Plane Bonus: City Immunity!`, CANVAS_WIDTH / 2, 390); // Adjusted Y
                }

                ctx.fillStyle = '#ff0';
                ctx.fillText('Preparing next level...', CANVAS_WIDTH / 2, 420); // Adjusted Y position
                
                ctx.textAlign = 'left';
            }

            // Draw end game screen
            function drawEndGame() {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
                
                ctx.font = 'bold 30px Arial';
                ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                
                ctx.fillStyle = '#ff0';
                ctx.fillText('CLICK TO PLAY AGAIN', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80);
                
                ctx.textAlign = 'left';
            }

            // Draw cities
            function drawCities() {
                cities.forEach(city => {
                    if(city.active) {
                        city.draw();
                    }
                });
            }

            // Draw anti-missile batteries
            function drawAntiMissileBatteries() {
                antiMissileBatteries.forEach(amb => {
                    if (amb.draw) { // Ensure the draw method exists (for destroyed state)
                        amb.draw();
                    }
                });
            }

            // Get score multiplier based on level
            function getMultiplier() {
                return Math.min(6, Math.floor((level + 1) / 2));
            }

            // Draw background with stars and ground
            function drawBackground() {
                // Black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Draw stars
                ctx.fillStyle = '#fff';
                for(let i = 0; i < 100; i++) {
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = Math.random() * (CANVAS_HEIGHT - GROUND_HEIGHT);
                    const size = Math.random() * 1.5;
                    ctx.fillRect(x, y, size, size);
                }
                
                // Draw ground
                const groundY = CANVAS_HEIGHT - GROUND_HEIGHT;
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);
                ctx.lineTo(0, groundY);
                
                let x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 20 + Math.random() * 30;
                    const heightVariation = Math.random() * 15;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                
                ctx.lineTo(CANVAS_WIDTH, groundY);
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();
                
                // Draw ground details
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.beginPath();
                x = 0;
                while(x < CANVAS_WIDTH) {
                    const segmentWidth = 50 + Math.random() * 50;
                    const heightVariation = Math.random() * 10;
                    ctx.lineTo(x + segmentWidth, groundY - heightVariation);
                    x += segmentWidth;
                }
                ctx.stroke();
            }

            // City class with improved graphics
            class City {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.active = true;
                    this.width = 60;
                    this.height = 40;
                }

                draw() {
                    if(!this.active) return;
                    
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;

                    ctx.fillStyle = '#222';
                    ctx.fillRect(baseX - 5, baseY - 10, this.width + 10, 10);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(baseX - 2, baseY - 12, this.width + 4, 2); 

                    const buildingTypes = [
                        { widthFactor: 0.2, heightFactor: 1.2, color: 'hsl(200, 80%, 50%)' },
                        { widthFactor: 0.25, heightFactor: 1.5, color: 'hsl(280, 80%, 60%)' },
                        { widthFactor: 0.22, heightFactor: 1.0, color: 'hsl(160, 70%, 55%)' }
                    ];
                    
                    let currentX = baseX + 5;

                    for (let i = 0; i < buildingTypes.length; i++) {
                        const type = buildingTypes[i];
                        const buildingWidth = this.width * type.widthFactor;
                        const buildingHeight = this.height * type.heightFactor;
                        const buildingColor = type.color;

                        ctx.fillStyle = buildingColor;
                        ctx.beginPath();
                        ctx.moveTo(currentX, baseY - 10);
                        ctx.lineTo(currentX, baseY - 10 - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - 10 - buildingHeight);
                        ctx.lineTo(currentX + buildingWidth, baseY - 10);
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = `rgba(0, 255, 255, 0.8)`;
                        ctx.fillRect(currentX + buildingWidth * 0.1, baseY - 10 - buildingHeight - 3, buildingWidth * 0.8, 3);
                        
                        ctx.fillStyle = '#0ff';
                        const panelHeight = 5;
                        const panelWidth = buildingWidth * 0.6;
                        for (let r = 0; r < Math.floor(buildingHeight / (panelHeight + 8)); r++) {
                            ctx.fillRect(currentX + (buildingWidth - panelWidth) / 2, 
                                         baseY - 10 - buildingHeight + 5 + r * (panelHeight + 8),
                                         panelWidth, panelHeight);
                        }
                        
                        currentX += buildingWidth + 5;
                    }

                    const domeRadius = this.width / 2;
                    const domeCenterX = this.x;
                    const domeCenterY = baseY - this.height * 1.3;

                    let domeGradient;
                    if (citiesImmune) { // Killer Plane bonus active
                        domeGradient = ctx.createRadialGradient(
                            domeCenterX, domeCenterY - domeRadius / 3, 0,
                            domeCenterX, domeCenterY, domeRadius
                        );
                        domeGradient.addColorStop(0, 'rgba(255, 255, 0, 0.9)'); // Bright yellow
                        domeGradient.addColorStop(0.8, 'rgba(200, 200, 0, 0.7)');
                        domeGradient.addColorStop(1, 'rgba(150, 150, 0, 0.5)');
                    } else {
                        domeGradient = ctx.createRadialGradient(
                            domeCenterX, domeCenterY - domeRadius / 3, 0,
                            domeCenterX, domeCenterY, domeRadius
                        );
                        domeGradient.addColorStop(0, 'rgba(0, 255, 255, 0.7)');
                        domeGradient.addColorStop(0.8, 'rgba(0, 100, 255, 0.5)');
                        domeGradient.addColorStop(1, 'rgba(0, 50, 150, 0.3)');
                    }

                    ctx.fillStyle = domeGradient;
                    ctx.beginPath();
                    ctx.arc(domeCenterX, domeCenterY, domeRadius, Math.PI, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = citiesImmune ? 'rgba(255, 255, 0, 1)' : 'rgba(0, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = citiesImmune ? '#ffff00' : '#0ff';
                    ctx.beginPath();
                    ctx.arc(domeCenterX - domeRadius * 0.8, domeCenterY, 2, 0, Math.PI * 2);
                    ctx.arc(domeCenterX + domeRadius * 0.8, domeCenterY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Anti-missile battery class
            class AntiMissileBattery {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.missilesLeft = 10;
                    this.width = 60; // Increased width
                    this.height = 50; // Increased height
                    this.active = true;
                    this.health = 3;
                    this.radarAngle = 0; // For radar animation
                    this.animationFrame = 0; // For general animations
                }

                hasMissile() {
                    return this.missilesLeft > 0 && this.active;
                }

                draw() {
                    const baseX = this.x - this.width / 2;
                    const baseY = this.y;
                    const siloHeight = 25; // Define siloHeight for VLS drawing

                    if (!this.active) {
                        // Destroyed state: rubble and broken structures
                        ctx.fillStyle = '#333'; // Dark gray rubble
                        ctx.beginPath();
                        ctx.moveTo(baseX, baseY);
                        ctx.lineTo(baseX + this.width, baseY);
                        ctx.lineTo(baseX + this.width - 5, baseY - 10);
                        ctx.lineTo(baseX + 5, baseY - 10);
                        ctx.closePath();
                        ctx.fill();

                        ctx.fillStyle = '#444';
                        ctx.beginPath();
                        ctx.moveTo(baseX + this.width * 0.2, baseY - 10);
                        ctx.lineTo(baseX + this.width * 0.8, baseY - 10);
                        ctx.lineTo(baseX + this.width * 0.7, baseY - 25);
                        ctx.lineTo(baseX + this.width * 0.3, baseY - 25);
                        ctx.closePath();
                        ctx.fill();

                        // Some debris
                        ctx.fillStyle = '#222';
                        ctx.fillRect(baseX + 10, baseY - 20, 5, 10);
                        ctx.fillRect(baseX + this.width - 15, baseY - 18, 7, 8);
                        ctx.fillRect(baseX + this.width / 2 - 3, baseY - 28, 6, 12);
                        return; // Stop drawing if inactive
                    }

                    this.animationFrame++;
                    this.radarAngle = (this.animationFrame * 5) % 360; // Rotate radar

                    // Base (Trapezoid)
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.lineTo(baseX + this.width, baseY);
                    ctx.lineTo(baseX + this.width - 10, baseY - 15);
                    ctx.lineTo(baseX + 10, baseY - 15);
                    ctx.closePath();
                    ctx.fill();

                    // Main Structure (Hexagon)
                    const hexTopY = baseY - 15 - this.height * 0.6;
                    const hexBaseY = baseY - 15;
                    const hexWidth = this.width * 0.8;
                    const hexX = this.x;

                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.moveTo(hexX, hexTopY);
                    ctx.lineTo(hexX + hexWidth / 2, hexBaseY - this.height * 0.3);
                    ctx.lineTo(hexX + hexWidth / 2, hexBaseY);
                    ctx.lineTo(hexX, hexBaseY + this.height * 0.3); // Bottom point
                    ctx.lineTo(hexX - hexWidth / 2, hexBaseY);
                    ctx.lineTo(hexX - hexWidth / 2, hexBaseY - this.height * 0.3);
                    ctx.closePath();
                    ctx.fill();

                    // Inner highlight for hexagon
                    const innerGradient = ctx.createLinearGradient(hexX - hexWidth / 2, hexTopY, hexX + hexWidth / 2, hexTopY);
                    innerGradient.addColorStop(0, '#777');
                    innerGradient.addColorStop(0.5, '#AAA');
                    innerGradient.addColorStop(1, '#777');
                    ctx.strokeStyle = innerGradient;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // VLS (Vertical Launch System) Silos
                    const siloCount = 4;
                    const siloWidth = 8;
                    const siloSpacing = (hexWidth - (siloCount * siloWidth)) / (siloCount + 1);
                    let currentSiloX = hexX - hexWidth / 2 + siloSpacing;

                    for (let i = 0; i < siloCount; i++) {
                        // Silo base
                        ctx.fillStyle = '#333';
                        ctx.fillRect(currentSiloX, hexBaseY - siloHeight, siloWidth, siloHeight);
                        
                        // Missile inside silo
                        if (this.missilesLeft > i) { // Draw missile if missiles are available
                            ctx.fillStyle = '#0f0'; // Missile color
                            ctx.fillRect(currentSiloX + 1, hexBaseY - siloHeight + 5, siloWidth - 2, siloHeight - 8);
                            // Missile tip
                            ctx.beginPath();
                            ctx.moveTo(currentSiloX + siloWidth / 2, hexBaseY - siloHeight + 5);
                            ctx.lineTo(currentSiloX + 1, hexBaseY - siloHeight + 10);
                            ctx.lineTo(currentSiloX + siloWidth - 1, hexBaseY - siloHeight + 10);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Silo lines
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(currentSiloX, hexBaseY - siloHeight, siloWidth, siloHeight);

                        currentSiloX += siloWidth + siloSpacing;
                    }

                    // Radar Dome
                    const radarRadius = 15;
                    const radarCenterX = this.x;
                    const radarCenterY = hexTopY - radarRadius + 5;

                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.arc(radarCenterX, radarCenterY, radarRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Radar arm (animated)
                    ctx.save(); // Save current canvas state
                    ctx.translate(radarCenterX, radarCenterY); // Move origin to radar center
                    ctx.rotate(this.radarAngle * Math.PI / 180); // Rotate by radarAngle
                    ctx.fillStyle = '#0ff';
                    ctx.fillRect(0, -1, radarRadius, 2); // Radar arm (thin line)
                    ctx.restore(); // Restore canvas state

                    // Missile count display (digital style)
                    ctx.fillStyle = '#0ff'; // Light blue/cyan
                    ctx.font = 'bold 12px "Press Start 2P", cursive, monospace'; // Pixelated font if available, else monospace
                    ctx.textAlign = 'center';
                    ctx.fillText(`${this.missilesLeft}`, this.x, hexTopY + 10); // Position above silos

                    // Health bar
                    if (this.health < 3 && this.active) {
                        const barWidth = this.width * 0.7;
                        const barHeight = 5;
                        const barX = this.x - barWidth / 2;
                        const barY = baseY + 5; // Positioned below the base

                        ctx.fillStyle = '#000'; // Background for the bar
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        const healthFillWidth = (this.health / 3) * barWidth;
                        ctx.fillStyle = (this.health === 1) ? 'red' : 'orange'; // Red for 1, Orange for 2
                        ctx.fillRect(barX, barY, healthFillWidth, barHeight);

                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }
                }
            }

            // Base Missile class
            class Missile {
                constructor(options) {
                    this.startX = options.startX;
                    this.startY = options.startY;
                    this.endX = options.endX;
                    this.endY = options.endY;
                    this.color = options.color;
                    this.trailColor = options.trailColor;
                    this.x = options.startX;
                    this.y = options.startY;
                    this.state = MISSILE.active;
                    this.width = 3;
                    this.height = 3;
                    this.explodeRadius = 0;
                    this.speedFactor = options.speedFactor || 1;
                    this.explosionSizeMultiplier = options.explosionSizeMultiplier || 1; // NEW: for stealth plane bonus
                }

                draw() {
                    if(this.state === MISSILE.active) {
                        const gradient = ctx.createLinearGradient(this.startX, this.startY, this.x, this.y);
                        gradient.addColorStop(0, this.trailColor);
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(this.startX, this.startY);
                        ctx.lineTo(this.x, this.y);
                        ctx.stroke();

                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if(this.color === '#0f0') {
                            ctx.shadowColor = this.color;
                            ctx.shadowBlur = 10;
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    } else if(this.state === MISSILE.exploding || this.state === MISSILE.imploding) {
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.explodeRadius
                        );
                        
                        if(this.state === MISSILE.exploding) {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            gradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.6)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        } else {
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                            gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        }
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        explodeOtherMissiles(this, ctx);
                    }
                }

                explode() {
                    const maxRadius = 40 * this.explosionSizeMultiplier; // Apply bonus here
                    const implodeRate = 3 * this.speedFactor;
                    const explodeRate = 2 * this.speedFactor;

                    if(this.state === MISSILE.exploding) {
                        this.explodeRadius += explodeRate;
                    }
                    if(this.explodeRadius > maxRadius) {
                        this.state = MISSILE.imploding;
                    }
                    if(this.state === MISSILE.imploding) {
                        this.explodeRadius -= implodeRate;
                        if(this.groundExplosion) {
                            if(this.target && this.target[2] instanceof City) {
                                // City immunity check
                                if (!citiesImmune) {
                                    this.target[2].active = false;
                                    // NEW: Check if all cities have been destroyed immediately
                                    checkAllCitiesDestroyed(); 
                                }
                            } else if (this.target && this.target[2] instanceof AntiMissileBattery) { // Target is an AntiMissileBattery
                                const targetBattery = this.target[2];
                                if (targetBattery.active) { // Only damage if battery is active
                                    targetBattery.health--;
                                    if (targetBattery.health <= 0) {
                                        targetBattery.active = false; // Deactivate if health runs out
                                        targetBattery.missilesLeft = 0; // No more missiles if destroyed
                                        playSound('batteryDestroyed'); // Optional sound for destroyed battery
                                        console.log('Battery destroyed!');
                                    }
                                }
                            }
                        }
                    }
                    if(this.explodeRadius < 0) {
                        this.state = MISSILE.exploded;
                    }
                }
            }

            // Player's Missile class
            class PlayerMissile extends Missile {
                constructor(source, endX, endY) {
                    const amb = antiMissileBatteries[source];
                    const speedFactor = (source === 1) ? 1.5 : 1;
                    
                    super({
                        startX: amb.x,
                        startY: amb.y,
                        endX: endX,
                        endY: endY,
                        color: '#0f0',
                        trailColor: 'rgba(0, 255, 255, 0.7)',
                        speedFactor: speedFactor,
                        explosionSizeMultiplier: stealthPlaneExplosionBonus // Pass the bonus
                    });

                    const xDistance = this.endX - this.startX;
                    const yDistance = this.endY - this.startY;
                    
                    const distance = Math.sqrt(xDistance * xDistance + yDistance * yDistance);
                    const distancePerFrame = 15 * this.speedFactor;
                    const scale = distance / distancePerFrame;

                    this.dx = xDistance / scale;
                    this.dy = yDistance / scale;
                    amb.missilesLeft--;
                }

                update() {
                    if(this.state === MISSILE.active && this.y <= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                    } else {
                        this.explode();
                    }
                }
            }

            // Player shoot function
            function playerShoot(x, y) {
                // Adjust coordinates to be relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;

                if(canvasY >= 50 && canvasY <= CANVAS_HEIGHT - GROUND_HEIGHT - 50) {
                    const source = whichAntiMissileBattery(canvasX);
                    if(source === -1) return;
                    
                    playerMissiles.push(new PlayerMissile(source, canvasX, canvasY));
                    
                    playSound('shoot');
                }
            }

            // Enemy's Missile class
            class EnemyMissile extends Missile {
                constructor(targets, isFast = false, waveSpeedFactor = 1, isFromPlane = false, planeX = 0, planeY = 0) {
                    let startX, startY;
                    if (isFromPlane) {
                        startX = planeX;
                        startY = planeY;
                    } else {
                        startX = rand(0, CANVAS_WIDTH);
                        startY = 0;
                    }
                    
                    const speedFactor = (isFast ? 1.5 : 1) * waveSpeedFactor;
                    const target = targets[rand(0, targets.length - 1)];
                    
                    super({
                        startX: startX,
                        startY: startY,
                        endX: target[0],
                        endY: target[1],
                        color: '#f00',
                        trailColor: 'rgba(255, 100, 100, 0.5)',
                        speedFactor: speedFactor
                    });

                    let baseSpeed = 800;
                    baseSpeed = Math.max(150, baseSpeed - (level * 50)); 
                    
                    const framesToTarget = (baseSpeed * (0.4 + Math.random() * 1.2)) / this.speedFactor; 

                    this.dx = (this.endX - this.startX) / framesToTarget;
                    this.dy = (this.endY - this.startY) / framesToTarget;
                    this.target = target;
                    
                    this.delay = isFromPlane ? 0 : rand(0, Math.max(10, 60 - level)); // No delay for plane missiles
                    this.groundExplosion = false;
                }

                update() {
                    if(this.delay) {
                        this.delay--;
                        return;
                    }
                    
                    if(this.state === MISSILE.active && this.y >= this.endY) {
                        this.x = this.endX;
                        this.y = this.endY;
                        this.state = MISSILE.exploding;
                        this.groundExplosion = true;
                        
                        playSound('explosion');
                    }
                    
                    if(this.state === MISSILE.active) {
                        this.x += this.dx;
                        this.y += this.dy;
                        
                        if(Math.random() < 0.1) {
                            this.x += (Math.random() - 0.5) * 3;
                        }
                    } else {
                        this.explode();
                    }
                }
            }

            // Enemy Plane class
            class EnemyPlane {
                constructor() {
                    this.width = 70;
                    this.height = 25;
                    this.y = rand(50, CANVAS_HEIGHT / 3); // Random height in the upper third
                    this.speed = rand(2, 4) * (1 + level * 0.1); // Random speed, increases with level
                    this.direction = Math.random() < 0.5 ? 1 : -1; // 1 for right, -1 for left
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width; // Starts off-screen
                    this.active = true;
                    this.missileLaunchCooldown = 60; // Frames between missile launches
                    this.currentMissileCooldown = rand(10, this.missileLaunchCooldown);
                    this.missilesToLaunch = rand(1, 3); // Number of missiles to launch
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            // Draw plane explosion
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                            gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#666'; // Plane body
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#444';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 20)), this.y + 15 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 15)), this.y + 5 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 5)), this.y - 15 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Cockpit
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.arc(this.x - (this.direction * this.width * 0.1), this.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 2;
                            if (this.explodeRadius > 80) {
                                this.exploded = false; // End explosion animation
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Launch missiles
                    if (this.missilesToLaunch > 0) {
                        this.currentMissileCooldown--;
                        if (this.currentMissileCooldown <= 0) {
                            const targets = viableTargets();
                            if (targets.length > 0) {
                                enemyMissiles.push(new EnemyMissile(targets, true, 1.2, true, this.x, this.y));
                                this.missilesToLaunch--;
                                playSound('shoot');
                            }
                            this.currentMissileCooldown = rand(30, this.missileLaunchCooldown); // Reset cooldown
                        }
                    }

                    // Remove plane if it goes off-screen and has finished launching missiles
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    }
                }

                // Method for when the plane is hit
                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 500 * getMultiplier(); // Bonus for shooting down the plane (ya implementado)
                    planesShotDownThisLevel++; // NUEVO: Incrementar el contador de aviones derribados
                    checkPlaneReconstructionBonus(); // NUEVO: Verificar el bonus de reconstrucción
                    playSound('explosion');
                }
            }

            // Spy Plane class
            class SpyPlane {
                constructor() {
                    this.width = 50; // Slightly smaller
                    this.height = 18;
                    this.y = rand(80, CANVAS_HEIGHT / 3 - 30); // Random height, slightly lower than enemy plane
                    this.speed = rand(3, 5) * (1 + level * 0.05); // Faster, but no missiles
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(200, 200, 200, 0.9)'); // Grayish explosion
                            gradient.addColorStop(0.5, 'rgba(100, 100, 100, 0.7)');
                            gradient.addColorStop(1, 'rgba(50, 50, 50, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#444'; // Darker gray color
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.7), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 15)), this.y + 10 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 10)), this.y + 3 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 3)), this.y - 10 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Small antenna/sensor on top
                    ctx.fillStyle = '#888';
                    ctx.fillRect(this.x - (this.direction * this.width * 0.2), this.y - this.height / 2 - 5, 2, 5);
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 1.5; // Slightly slower explosion
                            if (this.explodeRadius > 60) { // Smaller explosion radius
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 750 * getMultiplier(); // Higher bonus for spy plane
                    spyPlaneWaveMissileBonus += 2; // Increase missile bonus per wave for all active batteries
                    extraMissilesFromSpyPlane += 2; // Track for end-level summary (now represents total bonus per wave)
                    playSound('explosion');
                    console.log(`Spy Plane shot down! Missile bonus per wave increased by 2. Total bonus: ${spyPlaneWaveMissileBonus}`);
                }
            }

            // Stealth Plane class (NEW)
            class StealthPlane {
                constructor() {
                    this.width = 60; 
                    this.height = 20;
                    this.y = rand(100, CANVAS_HEIGHT / 3 - 50); // Slightly lower than spy plane
                    this.speed = rand(4, 6) * (1 + level * 0.08); // Even faster
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(100, 100, 150, 0.9)'); // Bluish-gray explosion
                            gradient.addColorStop(0.5, 'rgba(50, 50, 100, 0.7)');
                            gradient.addColorStop(1, 'rgba(20, 20, 50, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    // Stealth shape (simple triangle/delta wing)
                    ctx.fillStyle = '#222'; // Very dark grey/black
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Glare effect to suggest stealth/reflection
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x - (this.direction * this.width), this.y);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Outline (subtle)
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 1.8; // Medium explosion speed
                            if (this.explodeRadius > 70) { // Medium explosion radius
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 1000 * getMultiplier(); // Highest bonus for stealth plane
                    stealthPlaneExplosionBonus = 2; // Activate the bonus!
                    playSound('explosion');
                    console.log(`Stealth Plane shot down! Missile explosion radius doubled!`);
                }
            }

            // Cargo Plane class (NEW)
            class CargoPlane {
                constructor() {
                    this.width = 90; // Larger than other planes
                    this.height = 35;
                    this.y = rand(120, CANVAS_HEIGHT / 2.5); // Slightly lower and more visible
                    this.speed = rand(1, 2) * (1 + level * 0.05); // Slower
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 150, 0, 0.9)'); // Orange-brown explosion
                            gradient.addColorStop(0.5, 'rgba(150, 75, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(100, 50, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#8B4513'; // Brownish color (cargo plane)
                    // Main body
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.1), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2 + 5);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2 - 5);
                    ctx.closePath();
                    ctx.fill();

                    // Tail fin
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.9), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.9 + 5)), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.9 - 5)), this.y - this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings (larger and more pronounced)
                    ctx.fillStyle = '#777';
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.4), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 40)), this.y + 20 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 + 30)), this.y + 10 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.4 - 10)), this.y - 20 * this.direction);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Windows or cargo markings
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                    for(let i = 0; i < 3; i++) {
                        ctx.fillRect(this.x - (this.direction * (this.width * 0.2 + i * 15)), this.y - 5, 5, 10);
                    }
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 1.2; // Even slower explosion, large plane
                            if (this.explodeRadius > 90) { // Larger explosion radius
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Remove plane if it goes off-screen
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 1200 * getMultiplier(); // Highest bonus, slow and big target
                    // Apply cargo plane bonus: decrease enemy missiles by 2 per next wave, capped at 2 per level
                    cargoPlaneEnemyMissileReduction = Math.min(2 * level, cargoPlaneEnemyMissileReduction + 2); 
                    playSound('explosion');
                    console.log(`Cargo Plane shot down! Enemy missiles per wave reduced by 2 for the rest of the level!`);
                }
            }

            // Killer Plane class (NEW)
            class KillerPlane {
                constructor() {
                    this.width = 80;
                    this.height = 30;
                    this.y = rand(70, CANVAS_HEIGHT / 3 - 10); // Similar height to enemy plane
                    this.speed = rand(2.5, 4.5) * (1 + level * 0.12); // Slightly faster than enemy plane
                    this.direction = Math.random() < 0.5 ? 1 : -1;
                    this.x = this.direction === 1 ? -this.width : CANVAS_WIDTH + this.width;
                    this.active = true;
                    this.missileLaunchCooldown = 30; // Faster launch rate
                    this.currentMissileCooldown = rand(5, this.missileLaunchCooldown);
                    this.missilesToLaunch = rand(2, 6); // Double missiles
                    this.exploded = false;
                    this.explodeRadius = 0;
                }

                draw() {
                    if (!this.active) {
                        if (this.exploded) {
                            const gradient = ctx.createRadialGradient(
                                this.x, this.y, 0,
                                this.x, this.y, this.explodeRadius
                            );
                            gradient.addColorStop(0, 'rgba(255, 50, 0, 0.9)'); // Fiery explosion
                            gradient.addColorStop(0.5, 'rgba(200, 0, 0, 0.7)');
                            gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.explodeRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        return;
                    }

                    ctx.fillStyle = '#304030'; // Dark green camouflage
                    // Main body
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.8), this.y - this.height / 2);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y - this.height / 2 + 5);
                    ctx.lineTo(this.x - (this.direction * this.width), this.y + this.height / 2 - 5);
                    ctx.lineTo(this.x - (this.direction * this.width * 0.8), this.y + this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Wings (sharp, camouflaged)
                    ctx.fillStyle = '#203020'; // Even darker green for wings
                    ctx.beginPath();
                    ctx.moveTo(this.x - (this.direction * this.width * 0.3), this.y);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 + 30)), this.y + 18 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 + 20)), this.y + 8 * this.direction);
                    ctx.lineTo(this.x - (this.direction * (this.width * 0.3 - 8)), this.y - 18 * this.direction);
                    ctx.closePath();
                    ctx.fill();

                    // Cockpit/Sensor (subtle red glow)
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.beginPath();
                    ctx.arc(this.x - (this.direction * this.width * 0.15), this.y, 4, 0, Math.PI * 2);
                    ctx.shadowColor = 'red';
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                update() {
                    if (!this.active) {
                        if (this.exploded) {
                            this.explodeRadius += 2.5; // Fast explosion
                            if (this.explodeRadius > 100) { // Large explosion radius
                                this.exploded = false;
                            }
                        }
                        return;
                    }

                    this.x += this.speed * this.direction;

                    // Launch missiles
                    if (this.missilesToLaunch > 0) {
                        this.currentMissileCooldown--;
                        if (this.currentMissileCooldown <= 0) {
                            const targets = viableTargets();
                            if (targets.length > 0) {
                                enemyMissiles.push(new EnemyMissile(targets, true, 1.5, true, this.x, this.y)); // Faster missiles
                                this.missilesToLaunch--;
                                playSound('shoot');
                            }
                            this.currentMissileCooldown = rand(15, this.missileLaunchCooldown); // Reset cooldown
                        }
                    }

                    // Remove plane if it goes off-screen and has finished launching missiles
                    if (this.direction === 1 && this.x > CANVAS_WIDTH + this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    } else if (this.direction === -1 && this.x < -this.width && this.missilesToLaunch <= 0) {
                        this.active = false;
                    }
                }

                hit() {
                    this.active = false;
                    this.exploded = true;
                    score += 2000 * getMultiplier(); // Very high bonus
                    citiesImmune = true; // Activate city immunity for the rest of the wave
                    playSound('explosion');
                    console.log(`Killer Plane shot down! Cities are now immune for this wave!`);
                }
            }


            // Explode other missiles in radius
            function explodeOtherMissiles(missile, ctx) {
                if(!missile.groundExplosion) {
                    enemyMissiles.forEach(otherMissile => {
                        const distance = Math.sqrt(
                            Math.pow(missile.x - otherMissile.x, 2) +
                            Math.pow(missile.y - otherMissile.y, 2)
                        );
                        if(distance < missile.explodeRadius && otherMissile.state === MISSILE.active) {
                            score += 25 * getMultiplier();
                            otherMissile.state = MISSILE.exploding;
                        }
                    });

                    // Check if the player missile's explosion hits the enemy plane
                    if (enemyPlane && enemyPlane.active) {
                        const distanceToPlane = Math.sqrt(
                            Math.pow(missile.x - enemyPlane.x, 2) +
                            Math.pow(missile.y - enemyPlane.y, 2)
                        );
                        // Slightly increase the detection radius for the plane to make it easier to hit
                        if (distanceToPlane < missile.explodeRadius + 20) { 
                            enemyPlane.hit();
                            enemyPlane = null; // Remove the plane once hit
                        }
                    }

                    // Check if the player missile's explosion hits the spy plane
                    if (spyPlane && spyPlane.active) {
                        const distanceToSpyPlane = Math.sqrt(
                            Math.pow(missile.x - spyPlane.x, 2) +
                            Math.pow(missile.y - spyPlane.y, 2)
                        );
                        if (distanceToSpyPlane < missile.explodeRadius + 15) { // Smaller radius for smaller plane
                            spyPlane.hit();
                            spyPlane = null; // Remove the spy plane once hit
                        }
                    }

                    // Check if the player missile's explosion hits the stealth plane (NEW)
                    if (stealthPlane && stealthPlane.active) {
                        const distanceToStealthPlane = Math.sqrt(
                            Math.pow(missile.x - stealthPlane.x, 2) +
                            Math.pow(missile.y - stealthPlane.y, 2)
                        );
                        if (distanceToStealthPlane < missile.explodeRadius + 10) { // Even smaller radius, harder to hit
                            stealthPlane.hit();
                            stealthPlane = null; // Remove the stealth plane once hit
                        }
                    }

                    // Check if the player missile's explosion hits the cargo plane (NEW)
                    if (cargoPlane && cargoPlane.active) {
                        const distanceToCargoPlane = Math.sqrt(
                            Math.pow(missile.x - cargoPlane.x, 2) +
                            Math.pow(missile.y - cargoPlane.y, 2)
                        );
                        if (distanceToCargoPlane < missile.explodeRadius + 25) { // Larger radius due to larger size
                            cargoPlane.hit();
                            cargoPlane = null; // Remove the cargo plane once hit
                        }
                    }

                    // Check if the player missile's explosion hits the killer plane (NEW)
                    if (killerPlane && killerPlane.active) {
                        const distanceToKillerPlane = Math.sqrt(
                            Math.pow(missile.x - killerPlane.x, 2) +
                            Math.pow(missile.y - killerPlane.y, 2)
                        );
                        if (distanceToKillerPlane < missile.explodeRadius + 20) { // Decent radius for a large target
                            killerPlane.hit();
                            killerPlane = null; // Remove the killer plane once hit
                        }
                    }
                }
            }

            // NUEVO: Función para verificar el bonus de reconstrucción de avión
            function checkPlaneReconstructionBonus() {
                if (planesShotDownThisLevel >= 3) {
                    reconstructRandomDestroyedStructure();
                    planesShotDownThisLevel = 0; // Reiniciar el contador después del bonus
                }
            }

            // NUEVO: Función para reconstruir una estructura aleatoria destruida
            function reconstructRandomDestroyedStructure() {
                const destroyedCities = cities.filter(city => !city.active);
                const destroyedBatteries = antiMissileBatteries.filter(battery => !battery.active);

                const allDestroyed = [...destroyedCities, ...destroyedBatteries];

                if (allDestroyed.length > 0) {
                    const structureToRebuild = allDestroyed[rand(0, allDestroyed.length - 1)];
                    if (structureToRebuild instanceof City) {
                        structureToRebuild.active = true;
                        reconstructedCount++; // Incrementar contador de reconstrucciones
                        console.log("¡Ciudad reconstruida por derribar 3 aviones!");
                    } else if (structureToRebuild instanceof AntiMissileBattery) {
                        structureToRebuild.active = true;
                        structureToRebuild.health = 3; // Restaurar salud completa
                        structureToRebuild.missilesLeft = 10; // Recargar misiles
                        reconstructedCount++; // Incrementar contador de reconstrucciones
                        console.log("¡Lanzadera reconstruida por derribar 3 aviones!");
                    }
                }
            }


            // Get viable targets for enemy missiles
            function viableTargets() {
                const targets = [];

                // If cities are immune, enemy missiles can only target batteries
                if (citiesImmune) {
                    antiMissileBatteries.forEach(amb => {
                        if (amb.active) {
                            targets.push([amb.x, amb.y - amb.height, amb]);
                        }
                    });
                    // If no batteries are active and cities are immune, the missiles have nowhere to go.
                    // This could lead to a stalemate or strange behavior. For now, they will just try to go to a random spot on the ground.
                    if (targets.length === 0) {
                        targets.push([rand(0, CANVAS_WIDTH), CANVAS_HEIGHT - GROUND_HEIGHT + 10, null]); // Random spot on ground
                    }
                } else {
                    cities.forEach(city => {
                        if(city.active) {
                            targets.push([city.x, city.y - city.height + 10, city]);
                        }
                    });

                    while(targets.length > 3) {
                        targets.splice(rand(0, targets.length - 1), 1);
                    }

                    if(Math.random() < (level * 0.05)) { 
                        antiMissileBatteries.forEach(amb => {
                            // Only attack active batteries
                            if (amb.active) { 
                                targets.push([amb.x, amb.y - amb.height, amb]);
                            }
                        });
                    }
                }
                
                return targets;
            }

            // Game loop
            function nextFrame() {
                drawGameState();
                updateEnemyMissiles();
                drawEnemyMissiles();
                updatePlayerMissiles();
                drawPlayerMissiles();

                // Update and draw the enemy plane if active
                if (enemyPlane && enemyPlane.active) {
                    enemyPlane.update();
                    enemyPlane.draw();
                } else if (enemyPlane && enemyPlane.exploded) { // Draw plane explosion
                    enemyPlane.update();
                    enemyPlane.draw();
                }

                // Update and draw the spy plane if active
                if (spyPlane && spyPlane.active) {
                    spyPlane.update();
                    spyPlane.draw();
                } else if (spyPlane && spyPlane.exploded) { // Draw spy plane explosion
                    spyPlane.update();
                    spyPlane.draw();
                }

                // Update and draw the stealth plane if active (NEW)
                if (stealthPlane && stealthPlane.active) {
                    stealthPlane.update();
                    stealthPlane.draw();
                } else if (stealthPlane && stealthPlane.exploded) { 
                    stealthPlane.update();
                    stealthPlane.draw();
                }

                // Update and draw the cargo plane if active (NEW)
                if (cargoPlane && cargoPlane.active) {
                    cargoPlane.update();
                    cargoPlane.draw();
                } else if (cargoPlane && cargoPlane.exploded) { 
                    cargoPlane.update();
                    cargoPlane.draw();
                }

                // Update and draw the killer plane if active (NEW)
                if (killerPlane && killerPlane.active) {
                    killerPlane.update();
                    killerPlane.draw();
                } else if (killerPlane && killerPlane.exploded) { 
                    killerPlane.update();
                    killerPlane.draw();
                }
                
                // Check if wave ended (considering all planes)
                if (waveActive && enemyMissiles.length === 0 && 
                    (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded) && 
                    (!spyPlane || !spyPlane.active && !spyPlane.exploded) && 
                    (!stealthPlane || !stealthPlane.active && !stealthPlane.exploded) && // NEW
                    (!cargoPlane || !cargoPlane.active && !cargoPlane.exploded) && // NEW
                    (!killerPlane || !killerPlane.active && !killerPlane.exploded) // NEW
                ) {
                    waveActive = false;
                    stopLevel();
                    setTimeout(() => {
                        citiesImmune = false; // Reset city immunity after wave ends
                        if (currentWave < WAVES_PER_LEVEL) { 
                            startNextWave();
                        } else { 
                            checkEndLevel(); 
                        }
                    }, 3000);
                }
            }

            // Spawns an enemy plane
            function spawnEnemyPlane() {
                // Possibility for a plane to appear, only if no active one and we haven't reached the limit per level
                if (!enemyPlane && planesPerLevel < MAX_PLANES_PER_LEVEL) {
                    if (Math.random() < 0.3 + (level * 0.05)) { // 30% probability + 5% per level
                        setTimeout(() => {
                            enemyPlane = new EnemyPlane();
                            planesPerLevel++;
                            console.log(`Enemy plane appearing. Planes this level: ${planesPerLevel}`);
                        }, rand(2000, 5000)); // Appears after 2-5 seconds
                    }
                }
            }

            // Spawns a spy plane
            function spawnSpyPlane() {
                if (!spyPlane && spyPlanesAppearedThisLevel < MAX_SPY_PLANES_PER_LEVEL) {
                    if (Math.random() < 0.15 + (level * 0.02)) { // 15% probability + 2% per level (lower than enemy plane)
                        setTimeout(() => {
                            spyPlane = new SpyPlane();
                            spyPlanesAppearedThisLevel++; // Increment count
                            console.log(`Spy plane appearing! Spy planes this level: ${spyPlanesAppearedThisLevel}`);
                        }, rand(4000, 8000)); // Appears after 4-8 seconds
                    }
                }
            }

            // Spawns a stealth plane (NEW)
            function spawnStealthPlane() {
                // Stealth plane appears randomly between waves 5 and 10
                if (currentWave >= 5 && currentWave <= 10 && !stealthPlane && !stealthPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.20) { // 20% chance to spawn in eligible waves
                        setTimeout(() => {
                            stealthPlane = new StealthPlane();
                            stealthPlaneSpawnedThisLevel = true; // Set flag to true once spawned this level
                            console.log(`Stealth plane appearing in Wave ${currentWave}!`);
                        }, rand(4000, 7000)); 
                    }
                }
            }

            // Spawns a cargo plane (NEW)
            function spawnCargoPlane() {
                // Cargo plane appears randomly between waves 2 and 6
                if (currentWave >= 2 && currentWave <= 6 && !cargoPlane && !cargoPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.30) { // 30% chance to spawn in eligible waves
                        setTimeout(() => {
                            cargoPlane = new CargoPlane();
                            cargoPlaneSpawnedThisLevel = true; // Set flag to true once spawned this level
                            console.log(`Cargo plane appearing in Wave ${currentWave}!`);
                        }, rand(5000, 9000)); 
                    }
                }
            }

            // Spawns a Killer Plane (NEW)
            function spawnKillerPlane() {
                // Killer plane appears randomly between waves 6 and 10
                if (currentWave >= 6 && currentWave <= 10 && !killerPlane && !killerPlaneSpawnedThisLevel) {
                    if (Math.random() < 0.25) { // 25% chance to spawn in eligible waves
                        setTimeout(() => {
                            killerPlane = new KillerPlane();
                            killerPlaneSpawnedThisLevel = true; // Set flag to true once spawned this level
                            console.log(`Killer plane appearing in Wave ${currentWave}!`);
                        }, rand(6000, 10000)); 
                    }
                }
            }


            // Check for end of level
            function checkEndLevel() {
                // Consider all planes for wave/level end
                if(enemyMissiles.length === 0 && 
                    (!enemyPlane || !enemyPlane.active && !enemyPlane.exploded) && 
                    (!spyPlane || !spyPlane.active && !spyPlane.exploded) && 
                    (!stealthPlane || !stealthPlane.active && !stealthPlane.exploded) && // NEW
                    (!cargoPlane || !cargoPlane.active && !cargoPlane.exploded) && // NEW
                    (!killerPlane || !killerPlane.active && !killerPlane.exploded) // NEW
                ) {
                    stopLevel();
                    gameContainer.removeEventListener('click', handleShoot);
                    gameContainer.removeEventListener('mousemove', handleMouseMove);
                    crosshair.style.display = 'none';
                    
                    const missilesLeft = totalMissilesLeft();
                    const citiesSaved = totalCitiesSaved();

                    // The game over condition by cities is moved to checkAllCitiesDestroyed
                    if(citiesSaved === 0) {
                        endGame(missilesLeft); // This should be unreachable if checkAllCitiesDestroyed works
                    } else {
                        endLevel(missilesLeft, citiesSaved, planesShotDownThisLevel, reconstructedCount, spyPlaneWaveMissileBonus, stealthPlaneExplosionBonus === 2, cargoPlaneEnemyMissileReduction, citiesImmune); // Pass new parameters
                    }
                }
            }

            // Function to check if all cities have been destroyed
            function checkAllCitiesDestroyed() {
                if (totalCitiesSaved() === 0) {
                    stopLevel(); // Stop the game loop
                    gameContainer.removeEventListener('click', handleShoot); // Deactivate shooting
                    gameContainer.removeEventListener('mousemove', handleMouseMove); // Deactivate crosshair movement
                    crosshair.style.display = 'none'; // Hide crosshair
                    endGame(totalMissilesLeft()); // End the game
                }
            }


            // Handle end of level
            function endLevel(missilesLeft, citiesSaved, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthBonusActive, cargoMissileReduction, killerPlaneImmunityActive) { // Added killerPlaneImmunityActive
                const missilesBonus = missilesLeft * 5 * getMultiplier();
                const citiesBonus = citiesSaved * 100 * getMultiplier();

                drawEndLevel(missilesLeft, missilesBonus, citiesSaved, citiesBonus, planesShotDown, structuresRebuilt, spyPlaneBonus, stealthBonusActive, cargoMissileReduction, killerPlaneImmunityActive); // Pass new parameters

                setTimeout(() => {
                    score += missilesBonus + citiesBonus;
                }, 2000);

                setTimeout(setupNextLevel, 4000);
            }

            // Setup next level
            function setupNextLevel() {
                const previousScore = score; // Save score before adding end-of-level bonuses
                level++; 
                planesPerLevel = 0; // Reset plane counter for the new level
                planesShotDownThisLevel = 0; // Reiniciar contador de aviones derribados en el nuevo nivel
                reconstructedCount = 0; // Reiniciar contador de reconstrucciones para el nuevo nivel
                spyPlanesAppearedThisLevel = 0; // Reset spy plane count for the new level
                spyPlaneWaveMissileBonus = 0; // Reset spy plane missile bonus for the new level
                extraMissilesFromSpyPlane = 0; // Reset bonus missiles from spy plane for the new level
                stealthPlanesAppearedThisLevel = 0; // Reset stealth plane count for the new level
                stealthPlaneExplosionBonus = 1; // Reset bonus for the new level
                stealthPlaneSpawnedThisLevel = false; // Reset flag for new level
                cargoPlanesAppearedThisLevel = 0; // Reset cargo plane count for the new level
                cargoPlaneEnemyMissileReduction = 0; // Reset bonus
                cargoPlaneSpawnedThisLevel = false; // Reset flag for new level
                killerPlanesAppearedThisLevel = 0; // Reset killer plane count for the new level
                citiesImmune = false; // Reset city immunity for the new level
                killerPlaneSpawnedThisLevel = false; // Reset flag for new level

                // LEVEL 1 TO 2 REWARD LOGIC (previous)
                // Maintained, but rebuilding is now handled by the new general score logic.
                if (level === 2 && totalCitiesSaved() === 6) { // If all cities were saved in level 1
                    bonusMissilesForNextWave = 10; 
                    console.log("10 extra missiles per battery for Level 2 for saving all cities!"); 
                }

                // NEW LOGIC: Rebuild a city if level score was > 3000
                if (previousScore >= 3000) { // Evaluates the score from the PREVIOUS level
                    const destroyedCities = cities.filter(city => !city.active);
                    if (destroyedCities.length > 0) {
                        const cityToRebuild = destroyedCities[rand(0, destroyedCities.length - 1)];
                        cityToRebuild.active = true;
                        reconstructedCount++; // This counts reconstructions from score as well
                        console.log("City rebuilt due to high score!"); 
                    }
                }


                // Rebuild and repair all batteries for the new level
                antiMissileBatteries.forEach(amb => {
                    amb.active = true; // Activate battery
                    amb.health = 3;    // Restore full health
                });
                console.log("Launchers rebuilt and repaired!"); 

                initializeLevel(); 
                gameContainer.addEventListener('click', handleShoot);
                gameContainer.addEventListener('mousemove', handleMouseMove);
                crosshair.style.display = 'block';
            }

            // Handle end of game
            function endGame(missilesLeft) {
                score += missilesLeft * 5 * getMultiplier();
                drawEndGame();
                
                playSound('gameOver');

                const resetGame = () => {
                    document.removeEventListener('click', resetGame);
                    location.reload(); 
                };
                
                document.addEventListener('click', resetGame);
            }

            // Get total missiles left
            function totalMissilesLeft() {
                // Only count missiles from active batteries
                return antiMissileBatteries.filter(amb => amb.active).reduce((total, amb) => total + amb.missilesLeft, 0);
            }

            // Get total cities saved
            function totalCitiesSaved() {
                return cities.filter(city => city.active).length;
            }

            // Update enemy missiles
            function updateEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.update());
                enemyMissiles = enemyMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw enemy missiles
            function drawEnemyMissiles() {
                enemyMissiles.forEach(missile => missile.draw());
            }

            // Update player missiles
            function updatePlayerMissiles() {
                playerMissiles.forEach(missile => missile.update());
                playerMissiles = playerMissiles.filter(missile => missile.state !== MISSILE.exploded);
            }

            // Draw player missiles
            function drawPlayerMissiles() {
                playerMissiles.forEach(missile => missile.draw());
            }

            // Stop level animation
            function stopLevel() {
                cancelAnimationFrame(timerID);
            }

            // Start level animation
            function startLevel() {
                gameStarted = true;
                const animate = () => {
                    nextFrame();
                    timerID = requestAnimationFrame(animate);
                };
                animate();
            }

            // Determine which anti-missile battery to use
            function whichAntiMissileBattery(x) {
                // Modified to prioritize active batteries
                const getUsableBattery = (indices) => {
                    for (const index of indices) {
                        if (antiMissileBatteries[index].hasMissile()) {
                            return index;
                        }
                    }
                    return -1; // No usable battery found
                };

                // Check if any battery is active and has missiles
                if(!antiMissileBatteries.some(amb => amb.hasMissile())) {
                    return -1;
                }

                if(x <= CANVAS_WIDTH / 3) {
                    return getUsableBattery([0, 1, 2]);
                } else if(x <= (2 * CANVAS_WIDTH / 3)) {
                    if(antiMissileBatteries[1].hasMissile()) return 1;
                    return (x <= CANVAS_WIDTH / 2) ? getUsableBattery([0, 2]) : getUsableBattery([2, 0]);
                } else {
                    return getUsableBattery([2, 1, 0]);
                }
            }

            // Handle mouse move to update target crosshair position
            function handleMouseMove(event) {
                const rect = canvas.getBoundingClientRect();
                targetCrosshairX = event.clientX - rect.left;
                targetCrosshairY = event.clientY - rect.top;
            }

            // Handle shoot event 
            function handleShoot(event) {
                playerShoot(event.clientX, event.clientY);
            }

            // Toggle sound function for key press (button removed)
            function toggleSound() {
                soundEnabled = !soundEnabled;
                const soundStatus = soundEnabled ? 'ON' : 'OFF';
                console.log(`Sound: ${soundStatus}`);
                // You might want to update the splash screen text here if it's visible,
                // or provide some other visual feedback to the user.
            }

            // Handle key press for sound toggle
            function handleKeyPress(event) {
                if (event.key === 's' || event.key === 'S') {
                    toggleSound();
                }
            }

            // Simple sound effects (add sounds if you have the base64 data for 'batteryDestroyed' and 'hit')
            function playSound(type) {
                if(!soundEnabled || typeof Audio === 'undefined') return;
                
                try {
                    let sound;
                    switch(type) {
                        case 'shoot':
                            // Data for a short, sharp shooting sound
                            sound = new Audio('data:audio/wav;base64,UklGRqgoAQBXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQiwJgAAihoAAIgeAACFIgAAqCQAAKcnAACoJwAAeicAAIIfAACAIQAAmSEAAKMkAACOIwAAnCMAAJ4lAACKJQAAgiMAAIwjAACNIwAAhSMAAKclAACFJwAAkiQAAKIkAACWIgAAgyMAAIUfAACeHQAAjysAALMwAAC1LAAAsSwAAKctAACoJwAAnyIAAI4gAACuKQAAtisAALArAACzKQAAnCUAAJwiAACYIwAAkSUAAJwgAACjHgAAjyYAAIclAACJHQAAjyMAACdBAABcRAAA9w4AAD07AAC3LgAAty0AALMtAACvKwAAsCsAALEyAACiNwAAkDAAAIA4AAD1MwAA8S4AALMxAACrMAAAtzQAAK8xAACpLAQArjAAAKkwAAKg7AAC+LQAA7i4AADU+AACyNQAAtzQAAKA8AAD5LwAA7icAAFUQAACkIQAAmBoAAKgnAACYIgAAmSMAAJomAAClJQAAmiYAAKgoAACoKAACYIQAAnCQAAKkgAACgIQAAkSgAAL8wAACiKQAAmyQAAKUjAACaJQAAkSQAAJojAACaIAAAjiEAAJIgAACcIQAAoB8AAJoiAACYIwAAmiIAAJogAACKHwAAkCEAAIwfAACaJAAAmCMAAJYhAACaIAAAjycAALc5AAC+NwAAqS8AAKwvAAC3JwAAjyUAALQnAAC4JgAAqioAALIrAACxKgAAmyQAAJ4nAACgKAAApSUAAJwiAACYJAAAngAAAJYjAACZIgAAnSEAAJMfAACWIAAAmhoAAJEdAACXIwAAgR0AAJsgAAB1HAAAjSMAAFUaAACcIQAAjR4AAIAgAACbJAAAmCYAAJAjAACVIQAAkCEAAIwfAACDHAAAjyIAAJAhAACVJQAAkCMAAIwgAACMHAAAjyAAAKceAAB+HQAAmR8AAIAhAACaIQAAoyIAAKIgAACWJAAAkBwAAJ8hAACbIAAAkB8AAJkdAACWHgAAkiAAAJYhAACQIAAAmCEAAJYiAACgHwAAjB0AAIIdAACCIwAAihoAAIghAACXHQAAkR0AAJcfAACZIgAAiSAAAJYgAACaIAAAmCEAAJwiAACaIAAAmyIAAJsiAACZIwAAlyQAAJojAACXIwAAkCMASlVgGkXQ+0Jv/f3d6v/Wv/7U//4m/82//iT/6Q//yR/7q//1b//hU//n0P/r+/3q+P///wAAAA==');
                            break;
                        case 'gameOver':
                            // Data for a game over sound (usually a low, sustained tone or a series of tones)
                            sound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...');
                            break;
                        case 'batteryDestroyed': // Opcional: Sonido para cuando una batería es destruida
                            // sound = new Audio('data:audio/wav;base64,...'); 
                            console.log('Battery Destroyed Sound Placeholder');
                            break;
                        case 'hit': // Opcional: Sonido para cuando una batería es golpeada pero no destruida
                            // sound = new Audio('data:audio/wav;base64,...');
                            console.log('Battery Hit Sound Placeholder');
                            break;
                    }
                    
                    if(sound) {
                        sound.volume = 0.3;
                        sound.play().catch(e => console.log('Sound playback failed:', e));
                    }
                } catch(e) {
                    console.log('Sound error:', e);
                }
            }

            return {
                initialize,
                setupListeners
            };
        })();

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            missileCommand.initialize();
            missileCommand.setupListeners();
        });
    </script>
</body>
</html>
